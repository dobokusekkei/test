<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>構造計算アプリケーション v21.30</title>

<script src="https://cdn.tailwindcss.com"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom/server": "https://esm.sh/react-dom@18.2.0/server",
    "lucide-react": "https://esm.sh/lucide-react@0.294.0"
  }
}
</script>

<script src="https://unpkg.com/@babel/standalone@7.23.9/babel.min.js"></script>

<link rel="stylesheet" href="css/style.css">

<script src="js/materials.js"></script>

</head>

<body class="bg-slate-50 text-slate-800">
<div id="root"></div>

<script type="text/babel" data-type="module">
import React, { useState, useMemo, useEffect, useRef } from 'react';
import { createRoot } from 'react-dom/client';
import { createPortal } from 'react-dom';
import { renderToStaticMarkup } from 'react-dom/server';
import { Plus, Trash2, Activity, Settings, List, X, Layers, ChevronDown, ArrowRight, RotateCw, AlertTriangle, Save, FolderOpen, Printer, Edit3, HelpCircle, History, FileDown, Upload, ExternalLink } from 'lucide-react';

/**
 * ==========================================
 * [決定版] 構造計算アプリケーション v21.30
 * ==========================================
 */

// --- 外部ファイル(window)から定数を受け取る ---
const INITIAL_SPAN = window.INITIAL_SPAN;
const RESOLUTION = window.RESOLUTION;
const E_STEEL = window.E_STEEL;
const EPS = window.EPS;

const STEEL_DB = window.STEEL_DB;
const STEEL_LISTS = window.STEEL_LISTS;
const CONCRETE_STRENGTHS = window.CONCRETE_STRENGTHS;
const COLORS = window.COLORS;
const BEAM_TYPES = window.BEAM_TYPES;

const HISTORY_DATA = window.HISTORY_DATA;
const MANUAL_SECTIONS = window.MANUAL_SECTIONS;

// 荷重タイプの日本語ラベル
const LOAD_LABELS = { point: '集中', distributed: '等分布', trapezoid: '台形', moment: 'モーメント' };

/**
 * 別ウィンドウ管理用コンポーネント (NewWindow)
 */
function NewWindow({ children, onClose, title = "計算結果詳細" }) {
  const newWindow = useRef(null);
  const [container, setContainer] = useState(null);

  useEffect(() => {
    const win = window.open("", "_blank", "width=1000,height=800,left=100,top=100");
    if (!win) {
      alert("ポップアップがブロックされました。許可してください。");
      if (onClose) onClose();
      return;
    }
    
    newWindow.current = win;
    win.document.title = title;

    Array.from(document.styleSheets).forEach(styleSheet => {
      try {
        if (styleSheet.href) {
          const newLink = win.document.createElement('link');
          newLink.rel = 'stylesheet';
          newLink.href = styleSheet.href;
          win.document.head.appendChild(newLink);
        } else if (styleSheet.cssRules) {
          const newStyle = win.document.createElement('style');
          Array.from(styleSheet.cssRules).forEach(rule => {
            newStyle.appendChild(win.document.createTextNode(rule.cssText));
          });
          win.document.head.appendChild(newStyle);
        }
      } catch (e) {}
    });

    Array.from(document.scripts).forEach(script => {
        if (script.src && !script.src.includes('babel')) {
            const newScript = win.document.createElement('script');
            newScript.src = script.src;
            win.document.head.appendChild(newScript);
        }
    });

    const div = win.document.createElement('div');
    div.className = "p-4 min-h-screen bg-white";
    win.document.body.appendChild(div);
    win.document.body.className = "bg-slate-50";

    setContainer(div);

    win.onbeforeunload = () => {
      if (onClose) onClose();
    };

    return () => {
      if (newWindow.current) {
        newWindow.current.close();
      }
    };
  }, []);

  return container ? createPortal(children, container) : null;
}

/**
 * 別ウィンドウの中身用コンポーネント (ResultContent)
 */
function ResultContent({ results, sectionProps, loads, spans, supports, totalLength, finalPoiData, userPoi, setUserPoi }) {
    return (
        <div className="space-y-6">
            <div className="flex justify-between items-end border-b pb-2">
                <div>
                    <h2 className="text-xl font-bold text-slate-800">計算結果詳細ビュー</h2>
                    <p className="text-sm text-slate-500">断面: {sectionProps.label} / 全長: {totalLength.toFixed(2)}m</p>
                </div>
                <div className="text-right text-xs text-slate-400">
                    ※このウィンドウは印刷用に最適化されていません。<br/>印刷には親画面の「印刷」ボタンを使用してください。
                </div>
            </div>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <ResultBox label="最大M (+)" val={results.bounds.maxM_pos} x={results.bounds.maxM_pos_x} unit="kN·m" color="text-emerald-600" />
                <ResultBox label="最大M (-)" val={results.bounds.maxM_neg} x={results.bounds.maxM_neg_x} unit="kN·m" color="text-red-600" />
                <ResultBox label="最大たわみ" val={results.bounds.maxDeflection} x={results.bounds.maxDef_x} unit="mm" color="text-blue-600" />
                <ResultBox label="最大せん断" val={results.bounds.maxShear} x={results.bounds.maxShear_x} unit="kN" color="text-amber-600" />
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h3 className="font-bold text-slate-600 mb-4">応力図・変位図</h3>
                <AdvancedVisualizer spans={spans} supports={supports} totalLength={totalLength} loads={loads} results={results} userPoi={userPoi} />
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <PoiTable 
                    finalPoiData={finalPoiData} 
                    userPoi={userPoi} 
                    setUserPoi={setUserPoi} 
                    totalLength={totalLength} 
                    spans={spans} 
                    results={results}
                    sectionProps={sectionProps}
                />
            </div>
        </div>
    );
}

// ==========================================
// メインアプリケーション (App)
// ==========================================

function App() {
  const [spanStr, setSpanStr] = useState(INITIAL_SPAN);
  const [beamType, setBeamType] = useState('simple');
  const [loads, setLoads] = useState([{ id: 1, type: 'point', mag: 10, pos: 3, length: 0 }]);
  const [showHelp, setShowHelp] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [showResultWindow, setShowResultWindow] = useState(false);
    
  const [matType, setMatType] = useState('steel');
  const [steelShape, setSteelShape] = useState('H');
  const [steelProfileIdx, setSteelProfileIdx] = useState(9); 
  const [steelAxis, setSteelAxis] = useState('strong');
    
  const [manualI, setManualI] = useState("1000");
  const [manualZ, setManualZ] = useState("100");
  const [manualA, setManualA] = useState("30.0");
  const [manualE, setManualE] = useState("205");
    
  const [effI, setEffI] = useState("1.0"); 
  const [effZ, setEffZ] = useState("1.0");
  const [wallLength, setWallLength] = useState("1.0");

  const [rcFcIdx, setRcFcIdx] = useState(1);
  const [rcWidthStr, setRcWidthStr] = useState('300');
  const [rcDepthStr, setRcDepthStr] = useState('600');

  const [userPoi, setUserPoi] = useState([]); 

  const [newLoadType, setNewLoadType] = useState('point');
  const [newMagStart, setNewMagStart] = useState(10);
  const [newMagEnd, setNewMagEnd] = useState(10);
  const [newPos, setNewPos] = useState(0);
  const [newLength, setNewLength] = useState(2);

  const [calcError, setCalcError] = useState(null);

  const fileInputRef = useRef(null);

  const { spans, totalLength, supports } = useMemo(() => {
    const vals = normalizeText(spanStr).replace(/,/g, ' ').split(/\s+/).map(Number).filter(n => !isNaN(n) && n > 0);
    const safeVals = vals.length > 0 ? vals : [6.0];
    let s = safeVals;
    let supp = [];

    switch (beamType) {
      case 'simple': s = [safeVals[0]]; supp = ['pin', 'roller']; break;
      case 'fixed': s = [safeVals[0]]; supp = ['fixed', 'fixed']; break;
      case 'cantilever': s = [safeVals[0]]; supp = ['fixed', 'free']; break;
      case 'overhang_one': 
        if(s.length < 2) s = [s[0], s[0]*0.3]; 
        s = s.slice(0, 2); supp = ['pin', 'roller', 'free']; break;
      case 'overhang_both': 
        if(s.length < 3) { const main = s.length>=2?s[1]:s[0]; const sub = s.length>=1?s[0]:2.0; s = [sub, main, sub]; }
        s = s.slice(0, 3); supp = ['free', 'pin', 'roller', 'free']; break;
      case 'continuous2': 
        if(s.length < 2) s = [s[0], s[0]];
        s = s.slice(0, 2); supp = ['pin', 'roller', 'roller']; break;
      case 'continuous2_overhang': 
        if(s.length < 3) s = [s[0], s[0], s[0]*0.3];
        s = s.slice(0, 3); supp = ['pin', 'roller', 'roller', 'free']; break;
      case 'continuous3': 
        if(s.length < 3) s = [s[0], s[0], s[0]];
        s = s.slice(0, 3); supp = ['pin', 'roller', 'roller', 'roller']; break;
      default: s = [6.0]; supp = ['pin', 'roller'];
    }
    return { spans: s, totalLength: s.reduce((a,b)=>a+b, 0), supports: supp };
  }, [spanStr, beamType]);

  const sectionProps = useMemo(() => {
    let E = 0, I = 0, Z = 0, label = '', dims = {}, A = 0, w = 0;
    
    if (matType === 'manual') {
        const iVal = parseFloat(manualI);
        const zVal = parseFloat(manualZ);
        const aVal = parseFloat(manualA);
        const eVal = parseFloat(manualE);

        I = (isNaN(iVal) ? 0 : iVal) * 10000; 
        Z = (isNaN(zVal) ? 0 : zVal) * 1000;  
        A = (isNaN(aVal) ? 0 : aVal);         
        E = (isNaN(eVal) ? 0 : eVal) * 1000;  

        w = A * 0.785; 
        label = `任意断面 (I=${manualI}, Z=${manualZ})`;
        dims = { type: 'manual' }; 
    
    } else if (matType === 'steel') {
      E = E_STEEL; 
      const list = STEEL_LISTS[steelShape];
      const name = list[steelProfileIdx] || list[0];
      const props = getSteelProps(steelShape, name, steelAxis);
      dims = props;

      if (steelShape.includes('SheetPile')) {
          const wVal = parseFloat(wallLength);
          const safeWL = (isNaN(wVal) || wVal <= 0) ? 1.0 : wVal;
          const iVal = parseFloat(effI);
          const safeEffI = (isNaN(iVal) || iVal < 0) ? 1.0 : iVal;
          const zVal = parseFloat(effZ);
          const safeEffZ = (isNaN(zVal) || zVal < 0) ? 1.0 : zVal;

          I = props.I * safeEffI * safeWL;
          Z = props.Z * safeEffZ * safeWL;
          A = props.A * safeWL;
          w = props.w * safeWL;
          label = `${name} (L=${safeWL}m)`;
      } else {
          I = props.I; 
          Z = props.Z;
          A = props.A;
          w = props.w;
          label = `${name} (${steelAxis === 'strong' ? '強軸' : '弱軸'})`;
      }

    } else {
      const fcData = CONCRETE_STRENGTHS[rcFcIdx];
      const b = parseFloat(rcWidthStr) || 0;
      const D = parseFloat(rcDepthStr) || 0;
      E = fcData.Ec; I = (b * Math.pow(D, 3)) / 12; Z = (b * Math.pow(D, 2)) / 6; 
      dims = { H: D, B: b, type: 'RC' };
      const areaM2 = (b/1000)*(D/1000);
      A = areaM2 * 10000; 
      w = areaM2 * 2400; 
      label = `RC造 ${fcData.label} ${b}x${D}`;
    }
    return { E, I, Z, label, dims, shape: steelShape, axis: steelAxis, matType, effI, effZ, wallLength, A, w };
  }, [matType, steelShape, steelProfileIdx, steelAxis, rcFcIdx, rcWidthStr, rcDepthStr, effI, effZ, wallLength, manualI, manualZ, manualA, manualE]);

  const results = useMemo(() => {
    try {
      setCalcError(null);
      return solveGeneralBeam(spans, supports, loads, RESOLUTION, sectionProps);
    } catch (e) {
      console.error(e);
      setCalcError("解析エンジンでエラーが発生しました。入力を確認してください。");
      return generateEmptyResult();
    }
  }, [spans, supports, loads, sectionProps]);

  const autoPoiPoints = useMemo(() => {
    if(!results.bounds) return [];
    const R = (v) => Math.round(v * 1000) / 1000;
    const points = new Set();
    
    points.add(R(0));
    points.add(R(totalLength));
    
    let cx = 0;
    spans.forEach(s => { cx += s; points.add(R(cx)); });

    loads.forEach(l => {
        points.add(R(l.pos));
        if (l.type === 'moment') {
            points.add(R(Math.max(0, l.pos - 1e-6)));
            points.add(R(Math.min(totalLength, l.pos + 1e-6)));
        } else if(l.type !== 'point') {
            points.add(R(l.pos + l.length));
        }
    });

    if (results.bounds) {
        const b = results.bounds;
        [b.maxShear_x, b.maxM_pos_x, b.maxM_neg_x, b.maxDef_x].forEach(x => { if (x !== undefined) points.add(R(x)); });
    }
    if (results.spanBounds) {
        results.spanBounds.forEach(sb => {
            [sb.maxM_x, sb.minM_x, sb.maxQ_x, sb.minQ_x, sb.maxD_x, sb.minD_x].forEach(x => { if (x !== undefined) points.add(R(x)); });
        });
    }

    const findZeroCrossings = (data) => {
        const crossings = [];
        if (!data) return crossings;
        for (let i = 1; i < data.length - 1; i++) {
            if (data[i].y * data[i+1].y < -1e-6) {
                const x = data[i].x + (0 - data[i].y) * (data[i+1].x - data[i].x) / (data[i+1].y - data[i].y);
                crossings.push(x);
            } 
            else if (Math.abs(data[i].y) < 1e-6) {
                const prevY = data[i-1].y;
                const nextY = data[i+1].y;
                if (Math.abs(prevY) > 1e-4 || Math.abs(nextY) > 1e-4) crossings.push(data[i].x);
            }
        }
        return crossings;
    };
    findZeroCrossings(results.momentData).forEach(x => points.add(R(x)));
    findZeroCrossings(results.shearData).forEach(x => points.add(R(x)));

    return Array.from(points)
      .filter(p => p >= 0 && p <= totalLength)
      .sort((a, b) => a - b);
  }, [totalLength, spans.join(','), loads, results.bounds]);

  const finalPoiData = useMemo(() => {
      const merged = [];
      autoPoiPoints.forEach(x => merged.push({ type: 'auto', x, id: `auto-${x}` }));
      userPoi.forEach(p => merged.push({ type: 'user', x: p.x, id: p.id }));
      
      return merged.sort((a,b) => a.x - b.x).map(p => {
          return { ...p, res: getResultAt(p.x, results, sectionProps) };
      });
  }, [autoPoiPoints, userPoi, results, sectionProps]);

  const exportToCSV = () => {
    let csvContent = "\uFEFF";
    csvContent += `[INFO],Version,21.30,Date,${new Date().toLocaleDateString()}\n`;
    csvContent += `[INPUT_BASIC],SpanStr,"${spanStr}",BeamType,${beamType},MatType,${matType}\n`;
    
    if (matType === 'steel') {
        csvContent += `[INPUT_STEEL],Shape,${steelShape},ProfileIdx,${steelProfileIdx},Axis,${steelAxis}\n`;
        if (steelShape.includes('SheetPile')) {
            csvContent += `[INPUT_PILE],EffI,${effI},EffZ,${effZ},WallLength,${wallLength}\n`;
        }
    } else if (matType === 'manual') {
        csvContent += `[INPUT_MANUAL],I,${manualI},Z,${manualZ},A,${manualA},E,${manualE}\n`;
    } else if (matType === 'concrete') {
        csvContent += `[INPUT_RC],FcIdx,${rcFcIdx},Width,${rcWidthStr},Depth,${rcDepthStr}\n`;
    }
    
    csvContent += `[HEADER_LOAD],Id,Type,Mag,Pos,Length,MagEnd\n`;
    loads.forEach(l => {
        csvContent += `[LOAD],${l.id},${l.type},${l.mag},${l.pos},${l.length},${l.magEnd || 0}\n`;
    });

    csvContent += `[HEADER_POI],Id,x\n`;
    userPoi.forEach(p => {
        csvContent += `[USER_POI],${p.id},${p.x}\n`;
    });

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `structural_calc_${new Date().toISOString().slice(0,10)}.csv`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const importFromCSV = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    
    const parseCSVLine = (text) => {
        const result = [];
        let curr = '';
        let inQuote = false;
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            if (char === '"') inQuote = !inQuote;
            else if (char === ',' && !inQuote) { result.push(curr); curr = ''; }
            else curr += char;
        }
        result.push(curr);
        return result.map(s => s.trim().replace(/^"|"$/g, ''));
    };

    reader.onload = (e) => {
        try {
            const lines = e.target.result.split(/\r\n|\n/);
            const newLoads = [];
            const newUserPoi = [];
            let hasInput = false;
            
            lines.forEach(line => {
                if (!line.trim()) return;
                const cols = parseCSVLine(line);
                if(cols.length < 2) return;
                const tag = cols[0];
                
                if(tag === '[INPUT_BASIC]') {
                    hasInput = true;
                    setSpanStr(cols[2]);
                    setBeamType(cols[4]);
                    setMatType(cols[6]);
                } else if (tag === '[INPUT_STEEL]') {
                    setSteelShape(cols[2]);
                    setSteelProfileIdx(Number(cols[4]));
                    setSteelAxis(cols[6]);
                } else if (tag === '[INPUT_MANUAL]') {
                    setManualI(cols[2]);
                    setManualZ(cols[4]);
                    setManualA(cols[6]);
                    setManualE(cols[8]);
                } else if (tag === '[INPUT_RC]') {
                    setRcFcIdx(Number(cols[2]));
                    setRcWidthStr(cols[4]);
                    setRcDepthStr(cols[6]);
                } else if (tag === '[INPUT_PILE]') {
                    setEffI(cols[2]);
                    setEffZ(cols[4]);
                    setWallLength(cols[6]);
                } else if (tag === '[LOAD]') {
                    newLoads.push({
                        id: Number(cols[1]),
                        type: cols[2],
                        mag: Number(cols[3]),
                        pos: Number(cols[4]),
                        length: Number(cols[5]),
                        magEnd: Number(cols[6])
                    });
                } else if (tag === '[USER_POI]') {
                    newUserPoi.push({
                        id: Number(cols[1]),
                        x: Number(cols[2])
                    });
                }
            });
            
            if (hasInput) {
                setLoads(newLoads);
                setUserPoi(newUserPoi);
                setCalcError(null);
            }
        } catch (err) {
            setCalcError("ファイル読み込みエラー");
        }
    };
    reader.readAsText(file);
    event.target.value = '';
  };

  const addLoad = () => {
    const id = Date.now();
    let safePos = Math.max(0, Math.min(totalLength, Number(newPos)));
    let safeLength = Math.max(0, Number(newLength));
    if ((newLoadType === 'distributed' || newLoadType === 'trapezoid') && safePos + safeLength > totalLength) {
      safeLength = totalLength - safePos;
    }
    setLoads([...loads, {
      id, type: newLoadType, mag: Number(newMagStart), pos: safePos, length: safeLength,
      magEnd: newLoadType === 'trapezoid' ? Number(newMagEnd) : (newLoadType === 'distributed' ? Number(newMagStart) : 0)
    }]);
  };

  const handleTypeChange = (newType) => {
    setBeamType(newType);
    if(newType.includes('continuous3') && spanStr.indexOf(',')===-1) setSpanStr("5.0, 5.0, 5.0");
    else if(newType.includes('continuous2') && spanStr.indexOf(',')===-1) setSpanStr("5.0, 5.0");
    else if(newType.includes('overhang_one') && spanStr.indexOf(',')===-1) setSpanStr("6.0, 2.0");
    else if(newType.includes('overhang_both') && spanStr.indexOf(',')===-1) setSpanStr("2.0, 6.0, 2.0");
  };

  const handlePrint = () => {
      const reportHtml = renderToStaticMarkup(
          <PrintReport 
              params={{ 
                  spanStr, beamType, loads, matType, 
                  sectionProps, results, finalPoiData, 
                  spans, totalLength, supports,
                  userPoi // userPoiを渡す
              }} 
          />
      );

      const printWindow = window.open('', '_blank');
      if (!printWindow) {
          alert("ポップアップがブロックされました。");
          return;
      }

      const htmlContent = `
          <!DOCTYPE html>
          <html lang="ja">
          <head>
              <meta charset="UTF-8">
              <title>構造計算書</title>
              <script src="https://cdn.tailwindcss.com"><\/script>
              <style>
                  body { font-family: 'Helvetica Neue', Arial, sans-serif; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
                  @page { size: A4 portrait; margin: 10mm; }
                  @media print { .no-print { display: none; } .page-break { break-before: page; } .avoid-break { page-break-inside: avoid; } }
                  .container { max-width: 190mm; margin: 0 auto; background: white; padding: 5mm; }
              </style>
          </head>
          <body>
              <div class="container">${reportHtml}</div>
              <script>window.onload = () => { setTimeout(() => { window.print(); }, 800); };<\/script>
          </body>
          </html>
      `;

      printWindow.document.write(htmlContent);
      printWindow.document.close();
  };

  return (
    <div className="min-h-screen bg-slate-50 font-sans text-slate-800">
      <div className="no-print p-4 md:p-8">
        <div className="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6">
            {/* Header */}
            <div className="lg:col-span-12 flex flex-col md:flex-row md:items-center justify-between gap-4">
            <div>
                <h1 className="text-3xl font-bold text-slate-900 flex items-center gap-3">
                <Activity className="w-8 h-8 text-blue-600" />
                構造計算アプリ Pro <span className="text-sm font-normal text-slate-500 bg-slate-200 px-2 py-1 rounded">v21.30</span>
                </h1>
                <p className="text-slate-500 text-sm mt-1">任意断面入力・モーメント荷重対応・不連続点自動補正</p>
            </div>
            
            <div className="flex items-center gap-2">
                <button onClick={() => setShowHistory(true)} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><History className="w-4 h-4 text-blue-500" />履歴</button>
                <button onClick={() => setShowHelp(true)} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><HelpCircle className="w-4 h-4 text-blue-500" />ヘルプ</button>
                <button onClick={() => setShowResultWindow(!showResultWindow)} className={`flex items-center gap-2 px-3 py-2 border border-slate-300 rounded-lg text-sm font-bold shadow-sm transition-all ${showResultWindow ? 'bg-blue-100 text-blue-700 border-blue-400' : 'bg-white text-slate-600 hover:bg-slate-50'}`}>
                <ExternalLink className="w-4 h-4" />別窓結果
                </button>
                <button onClick={handlePrint} className="flex items-center gap-2 px-3 py-2 bg-blue-600 border border-transparent rounded-lg text-sm font-bold text-white hover:bg-blue-700 shadow-sm transition-all"><Printer className="w-4 h-4" />印刷</button>
                
                <button onClick={exportToCSV} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><FileDown className="w-4 h-4" />結果出力(CSV)</button>
                <button onClick={() => fileInputRef.current?.click()} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><Upload className="w-4 h-4" />読込(CSV)</button>
                <input type="file" ref={fileInputRef} accept=".csv" onChange={importFromCSV} className="hidden" />
            </div>
            </div>

            {/* Modals */}
            {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
            {showHistory && <VersionHistoryModal onClose={() => setShowHistory(false)} />}

            {/* Sidebar */}
            <div className="lg:col-span-4 space-y-6">
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2"><Settings className="w-5 h-5 text-slate-400" />モデル・荷重</h2>
                    <div className="space-y-4 mb-6">
                        <div>
                            <label className="text-xs font-bold text-slate-500 block mb-1">梁タイプ</label>
                            <select value={beamType} onChange={(e) => handleTypeChange(e.target.value)} className="w-full p-2 border border-slate-300 rounded text-sm">
                            {Object.entries(BEAM_TYPES).map(([key, val]) => <option key={key} value={key}>{val.label}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="text-xs font-bold text-slate-500 block mb-1">スパン長さ (m)</label>
                            <input type="text" value={spanStr} onChange={e=>setSpanStr(e.target.value)} className="w-full p-2 border rounded text-sm" placeholder="例: 6.0"/>
                        </div>
                    </div>
                    <div className="border-t pt-4">
                        <h3 className="text-sm font-bold text-slate-600 mb-3">荷重追加</h3>
                        <div className="flex bg-slate-100 p-1 rounded mb-4">{['point', 'distributed', 'trapezoid', 'moment'].map(type => (<button key={type} onClick={() => setNewLoadType(type)} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${newLoadType === type ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>{LOAD_LABELS[type]}</button>))}</div>
                        <div className="space-y-3 mb-4">
                            <div className="flex gap-2">
                                <div className="w-1/2"><label className="text-xs text-slate-500 block">荷重(始)</label><input type="number" value={newMagStart} onChange={e=>setNewMagStart(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                                {newLoadType==='trapezoid' && <div className="w-1/2"><label className="text-xs text-slate-500 block">荷重(終)</label><input type="number" value={newMagEnd} onChange={e=>setNewMagEnd(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>}
                            </div>
                            <div className="flex gap-2">
                                <div className="w-1/2"><label className="text-xs text-slate-500 block">位置 x</label><input type="number" value={newPos} onChange={e=>setNewPos(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                                {newLoadType!=='point' && newLoadType!=='moment' && <div className="w-1/2"><label className="text-xs text-slate-500 block">長さ L</label><input type="number" value={newLength} onChange={e=>setNewLength(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>}
                            </div>
                        </div>
                        <button onClick={addLoad} className="w-full py-2 bg-blue-600 text-white rounded text-sm font-bold hover:bg-blue-700 flex items-center justify-center gap-2"><Plus className="w-4 h-4"/> 荷重を追加</button>
                    </div>
                    <div className="mt-4 space-y-1 max-h-[150px] overflow-y-auto text-sm">
                        {loads.map(l => (
                            <div key={l.id} className="flex justify-between items-center p-2 bg-slate-50 border rounded">
                            <div className="flex flex-col"><span className="font-bold text-slate-700">{LOAD_LABELS[l.type]} = {l.mag}</span><span className="text-xs text-slate-500">x={l.pos}</span></div>
                            <button onClick={()=>setLoads(loads.filter(x=>x.id!==l.id))}><Trash2 className="w-4 h-4 text-slate-300 hover:text-red-500"/></button>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                    <h2 className="text-lg font-semibold mb-4 flex items-center gap-2"><Layers className="w-5 h-5 text-slate-400" />断面・材料設定</h2>
                    <div className="flex bg-slate-100 p-1 rounded-lg mb-4">
                        <button onClick={() => setMatType('steel')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'steel' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>S造</button>
                        <button onClick={() => setMatType('concrete')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'concrete' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>RC造</button>
                        <button onClick={() => setMatType('manual')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'manual' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>任意</button>
                    </div>

                    {matType === 'steel' && (
                        <div className="space-y-4">
                            <div>
                                <label className="text-xs text-slate-500 font-bold block mb-1">鋼材種別</label>
                                <select value={steelShape} onChange={e => { setSteelShape(e.target.value); setSteelProfileIdx(0); }} className="w-full p-2 border rounded text-sm">
                                    <option value="H">H形鋼</option>
                                    <option value="Channel">溝形鋼</option>
                                    <option value="LipChannel">C形鋼</option>
                                    <option value="Angle">山形鋼</option>
                                    <option value="SheetPile">鋼矢板 (U形)</option>
                                    <option value="SheetPileW">鋼矢板 (広幅/w)</option>
                                    <option value="SheetPileH">鋼矢板 (ハット形)</option>
                                    <option value="LightSheetPile">軽量鋼矢板</option>
                                    <option value="SquarePipe">角形鋼管</option>
                                </select>
                            </div>
                            <div>
                                <label className="text-xs text-slate-500 font-bold block mb-1">断面サイズ</label>
                                <select value={steelProfileIdx} onChange={e => setSteelProfileIdx(Number(e.target.value))} className="w-full p-2 border rounded text-sm font-mono">{STEEL_LISTS[steelShape].map((name, idx) => <option key={idx} value={idx}>{name}</option>)}</select>
                            </div>
                            {(!steelShape.includes('SheetPile') && !steelShape.includes('SquarePipe')) && (
                                <div className="flex bg-slate-50 border rounded p-1"><button onClick={() => setSteelAxis('strong')} className={`flex-1 text-xs py-1 rounded font-bold ${steelAxis === 'strong' ? 'bg-blue-100 text-blue-700' : 'text-slate-400'}`}>強軸 (X)</button><button onClick={() => setSteelAxis('weak')} className={`flex-1 text-xs py-1 rounded font-bold ${steelAxis === 'weak' ? 'bg-blue-100 text-blue-700' : 'text-slate-400'}`}>弱軸 (Y)</button></div>
                            )}
                            {steelShape.includes('SheetPile') && (
                                <div className="mt-2 space-y-2 p-3 bg-yellow-50 rounded border border-yellow-200">
                                    <label className="text-[10px] text-slate-500 font-bold block">施工延長 L (m)</label>
                                    <input type="number" step="0.1" value={wallLength} onChange={e=>setWallLength(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right font-bold text-blue-600"/>
                                </div>
                            )}
                        </div>
                    )}
                    
                    {matType === 'concrete' && (
                        <div className="space-y-4">
                            <div><label className="text-xs text-slate-500 font-bold block mb-1">コンクリート</label><select value={rcFcIdx} onChange={e => setRcFcIdx(Number(e.target.value))} className="w-full p-2 border rounded text-sm">{CONCRETE_STRENGTHS.map((fc, idx) => <option key={idx} value={idx}>{fc.label}</option>)}</select></div>
                            <div className="grid grid-cols-2 gap-3">
                            <div><label className="text-xs text-slate-500 font-bold block mb-1">幅 b</label><input type="number" value={rcWidthStr} onChange={e=>setRcWidthStr(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                            <div><label className="text-xs text-slate-500 font-bold block mb-1">高さ D</label><input type="number" value={rcDepthStr} onChange={e=>setRcDepthStr(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                            </div>
                        </div>
                    )}

                    {matType === 'manual' && (
                        <div className="space-y-3 bg-blue-50 p-4 rounded border border-blue-100">
                            <div><label className="text-[10px] text-slate-500 font-bold block">Ix (cm⁴)</label><input type="number" value={manualI} onChange={e=>setManualI(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/></div>
                            <div><label className="text-[10px] text-slate-500 font-bold block">Zx (cm³)</label><input type="number" value={manualZ} onChange={e=>setManualZ(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/></div>
                            <div><label className="text-[10px] text-slate-500 font-bold block">E (kN/mm²)</label><input type="number" value={manualE} onChange={e=>setManualE(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/></div>
                            <div><label className="text-[10px] text-slate-500 font-bold block">A (cm²)</label><input type="number" value={manualA} onChange={e=>setManualA(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/></div>
                        </div>
                    )}

                    <div className="mt-4 grid grid-cols-2 gap-4">
                        <div className="p-3 bg-slate-50 rounded border text-xs space-y-1 font-mono text-slate-600">
                            <div className="flex justify-between"><span>Ix:</span> <span>{(sectionProps.I/10000).toFixed(3)} cm⁴</span></div>
                            <div className="flex justify-between"><span>Zx:</span> <span>{(sectionProps.Z/1000).toFixed(3)} cm³</span></div>
                            <div className="flex justify-between"><span>E :</span> <span>{(sectionProps.E/1000).toFixed(1)} kN/mm²</span></div>
                        </div>
                        <div className="flex items-center justify-center bg-white border rounded aspect-square p-2"><SectionProfileView props={sectionProps} /></div>
                    </div>
                </div>
            </div>

            {/* Main Content */}
            <div className="lg:col-span-8 space-y-6">
                <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                    <ResultBox label="最大M (+)" val={results.bounds.maxM_pos} x={results.bounds.maxM_pos_x} unit="kN·m" color="text-emerald-600" sub={`σ=${results.bounds.maxSigma_pos.toFixed(0)}`} />
                    <ResultBox label="最大M (-)" val={results.bounds.maxM_neg} x={results.bounds.maxM_neg_x} unit="kN·m" color="text-red-600" sub={`σ=${Math.abs(results.bounds.maxSigma_neg).toFixed(0)}`} />
                    <ResultBox label="最大たわみ" val={results.bounds.maxDeflection} x={results.bounds.maxDef_x} unit="mm" color="text-blue-600" />
                    <ResultBox label="最大せん断" val={results.bounds.maxShear} x={results.bounds.maxShear_x} unit="kN" color="text-amber-600" />
                    {results.reactions.map((r, i) => (
                    <ResultBox key={i} label={`反力 ${r.label}`} val={r.val} unit="kN" color="text-purple-600" sub={`@${r.x.toFixed(1)}m`} />
                    ))}
                </div>
                
                {calcError ? (
                    <div className="bg-red-50 border-red-200 border p-4 text-red-700 rounded flex items-center gap-2"><AlertTriangle className="w-5 h-5"/>{calcError}</div>
                ) : (
                    <>
                    <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 overflow-hidden">
                        <h2 className="text-sm font-bold text-slate-500 mb-4 flex items-center justify-between">
                        <span>解析結果グラフ ({sectionProps.label})</span>
                        </h2>
                        <AdvancedVisualizer spans={spans} supports={supports} totalLength={totalLength} loads={loads} results={results} userPoi={userPoi} />
                    </div>
                    <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                        <PoiTable 
                            finalPoiData={finalPoiData} 
                            userPoi={userPoi} 
                            setUserPoi={setUserPoi} 
                            totalLength={totalLength} 
                            spans={spans} 
                            results={results}
                            sectionProps={sectionProps}
                        />
                    </div>
                    </>
                )}
            </div>
        </div>
      </div> 

      {/* 別ウィンドウ管理 (ResultWindow -> NewWindow に修正済み) */}
      {showResultWindow && (
        <NewWindow onClose={() => setShowResultWindow(false)}>
            <ResultContent 
                results={results}
                sectionProps={sectionProps}
                loads={loads}
                spans={spans}
                supports={supports}
                totalLength={totalLength}
                finalPoiData={finalPoiData}
                userPoi={userPoi}
                setUserPoi={setUserPoi}
            />
        </NewWindow>
      )}
      
    </div>
  );
}

// ==========================================
// ヘルパー関数群 (Utility & Solvers)
// ==========================================

function normalizeText(text) {
  if (!text) return "";
  return text.replace(/、/g, ",").replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
}

function getSteelProps(shape, name, axis) {
    if (!STEEL_DB[name]) return { I:0, Z:0, A:0, w:0, H:100, B:100, t1:6, t2:8 };
    const d = STEEL_DB[name];
    
    // Parse dimensions from name string if not present in DB
    let H=100, B=100, t1=6, t2=9;
    // Remove prefix like H-, C-, L-, Square-
    const nums = name.replace(/^[a-zA-Z]+-/, '').split('x').map(Number);
    if (nums.length >= 2) { H = nums[0]; B = nums[1]; }
    if (nums.length >= 3) t1 = nums[2];
    if (nums.length >= 4) t2 = nums[3];
    
    // Overwrite if DB has specific values (SheetPile, etc)
    if (d.H) H = d.H;
    if (d.B) B = d.B;
    if (d.t) t1 = d.t;
    if (d.t1) t1 = d.t1;
    if (d.t2) t2 = d.t2;

    if (shape === 'SquarePipe' || shape === 'Angle') {
         return { ...d, I: d.Ix * 10000, Z: d.Zx * 1000, A: d.A, w: d.w, H, B, t1, t2 };
    }
    // SheetPile logic
    if (shape.includes('SheetPile')) {
        return { ...d, I: d.Ix * 10000, Z: d.Zx * 1000, A: d.A, w: d.w, H, B, t1 };
    }
    // Default H, C
    if (axis === 'weak') {
        return { ...d, I: d.Iy * 10000, Z: d.Zy * 1000, A: d.A, w: d.w, H, B, t1, t2 };
    }
    return { ...d, I: d.Ix * 10000, Z: d.Zx * 1000, A: d.A, w: d.w, H, B, t1, t2 };
}

// --------------------------------------------------------
// VersionHistoryModal
// --------------------------------------------------------
function VersionHistoryModal({ onClose }) {
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b flex justify-between items-center bg-slate-50">
                    <h2 className="text-lg font-bold flex items-center gap-2 text-slate-800"><History className="w-5 h-5 text-blue-600" />更新履歴</h2>
                    <button onClick={onClose} className="p-1 hover:bg-slate-200 rounded-full transition-colors"><X className="w-5 h-5 text-slate-500" /></button>
                </div>
                <div className="p-0 overflow-y-auto max-h-[60vh]">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-slate-100 text-slate-500 font-medium"><tr><th className="p-3 border-b">Version</th><th className="p-3 border-b">Date</th><th className="p-3 border-b">Description</th></tr></thead>
                        <tbody className="divide-y">
                            {HISTORY_DATA.map((h, i) => (
                                <tr key={i} className="hover:bg-slate-50">
                                    <td className="p-3 font-mono font-bold text-blue-600 align-top">{h.ver}</td>
                                    <td className="p-3 text-slate-500 text-xs align-top whitespace-nowrap">{h.date}</td>
                                    <td className="p-3 text-slate-700 align-top">{h.desc}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
                <div className="p-4 border-t bg-slate-50 text-right"><button onClick={onClose} className="px-4 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 transition-colors">閉じる</button></div>
            </div>
        </div>
    );
}

// --------------------------------------------------------
// HelpModal
// --------------------------------------------------------
function HelpModal({ onClose }) {
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-3xl max-h-[85vh] overflow-hidden flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b flex justify-between items-center bg-slate-50">
                    <h2 className="text-lg font-bold flex items-center gap-2 text-slate-800"><HelpCircle className="w-5 h-5 text-blue-600" />ユーザーマニュアル</h2>
                    <button onClick={onClose} className="p-1 hover:bg-slate-200 rounded-full transition-colors"><X className="w-5 h-5 text-slate-500" /></button>
                </div>
                <div className="p-6 overflow-y-auto text-sm text-slate-700 leading-relaxed space-y-6">
                    {MANUAL_SECTIONS.map((sec, i) => (
                        <section key={i}>
                            <h3 className="font-bold text-slate-900 border-l-4 border-blue-500 pl-2 mb-2">{sec.title}</h3>
                            <div dangerouslySetInnerHTML={{ __html: sec.content }} />
                        </section>
                    ))}
                </div>
                <div className="p-4 border-t bg-slate-50 text-right"><button onClick={onClose} className="px-4 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 transition-colors">閉じる</button></div>
            </div>
        </div>
    );
}

// --------------------------------------------------------
// PrintReport (印刷用)
// --------------------------------------------------------
function PrintReport({ params }) {
    const { sectionProps, results, loads, spans, totalLength, beamType, finalPoiData, userPoi } = params;
    const today = new Date().toLocaleDateString('ja-JP');
    return (
        <div className="space-y-6 text-sm text-slate-800">
            <header className="border-b-2 border-slate-800 pb-2 mb-4 flex justify-between items-end">
                <div><h1 className="text-xl font-bold text-slate-900">構造計算書</h1><p className="text-xs text-slate-500">Structural Analysis Report</p></div>
                <div className="text-right"><p className="font-bold text-sm">作成日: {today}</p><p className="text-xs text-slate-500">Ver 21.30</p></div>
            </header>
            <div className="grid grid-cols-2 gap-6 mb-4 avoid-break">
                <section>
                    <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">1. 設計条件</h2>
                    <table className="w-full text-left text-xs border-collapse">
                        <tbody>
                            <tr className="border-b"><th className="py-1 text-slate-500 w-24">梁タイプ</th><td className="font-bold">{BEAM_TYPES[beamType]?.label}</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">スパン構成</th><td className="font-mono">{spans.map(s=>s.toFixed(2)+'m').join(' + ')} (L={totalLength.toFixed(2)}m)</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">使用材料</th><td className="font-bold">{sectionProps.label}</td></tr>
                        </tbody>
                    </table>
                </section>
                <section>
                    <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">2. 荷重条件</h2>
                    <table className="w-full text-xs text-left border border-slate-200">
                        <thead className="bg-slate-100"><tr><th className="p-1 border">No.</th><th className="p-1 border">種類</th><th className="p-1 border">大きさ</th><th className="p-1 border">位置</th></tr></thead>
                        <tbody>
                            {loads.map((l, i) => (
                                <tr key={l.id} className="border-b">
                                    <td className="p-1 border text-center">{i+1}</td>
                                    <td className="p-1 border">{LOAD_LABELS[l.type]}</td>
                                    <td className="p-1 border font-mono">{l.mag}</td>
                                    <td className="p-1 border font-mono">{l.pos}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </section>
            </div>
            <section className="mb-4 avoid-break">
                <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">3. 応力図</h2>
                <div className="border rounded p-2 flex justify-center bg-white"><AdvancedVisualizer {...params} forceWidth={580} userPoi={userPoi} /></div>
            </section>
        </div>
    );
}

// --------------------------------------------------------
// [CORE ENGINE] Solver Logic
// --------------------------------------------------------
function solveGeneralBeam(spans, supports, loads, resolution, props) {
  const totalL = spans.reduce((a, b) => a + b, 0);
  const validSupportIndices = supports.map((s, i) => s !== 'free' ? i : -1).filter(i => i !== -1);
  if (validSupportIndices.length < 1) return generateEmptyResult();

  const idxStart = validSupportIndices[0];
  const idxEnd = validSupportIndices[validSupportIndices.length - 1];

  const spanLoads = spans.map(() => []);
  let cx = 0;
  spans.forEach((len, i) => {
    const sx = cx; const ex = cx + len;
    loads.forEach(l => {
      // Fixed support moment exclusion logic
      if (l.type === 'moment' && l.pos === 0 && supports[0] === 'fixed') return;
      if (l.type === 'moment' && l.pos === totalL && supports[supports.length - 1] === 'fixed') return;

      const lStart = l.pos;
      const lEnd = l.type === 'point' || l.type === 'moment' ? l.pos : l.pos + l.length;
      const oStart = Math.max(sx, lStart);
      const oEnd = Math.min(ex, lEnd);
      if ((oEnd > oStart + EPS) || ((l.type === 'point' || l.type === 'moment') && lStart >= sx - EPS && (i === spans.length-1 ? lStart <= ex + EPS : lStart < ex - EPS))) {
        let mag = l.mag; let magEnd = l.magEnd;
        if (l.type === 'trapezoid') {
           const slope = (l.magEnd - l.mag) / l.length;
           mag = l.mag + slope * (oStart - l.pos);
           magEnd = l.mag + slope * (oEnd - l.pos);
        }
        spanLoads[i].push({ ...l, pos: oStart - sx, length: oEnd - oStart, mag, magEnd });
      }
    });
    cx += len;
  });

  // Calculate Fixed End Moments
  let M_start = 0; 
  if (idxStart > 0) {
    for (let i = 0; i < idxStart; i++) {
       const distToSupport = spans.slice(i+1, idxStart).reduce((a,b)=>a+b, 0);
       spanLoads[i].forEach(l => {
         if (l.type === 'moment') M_start += l.mag;
         else {
             const { totalForce, momentA } = getLoadIntegral(l);
             const xc = totalForce !== 0 ? momentA / totalForce : 0;
             const arm = (spans[i] - xc) + distToSupport;
             M_start -= totalForce * arm; 
         }
       });
    }
  }
  let M_end = 0;
  if (idxEnd < spans.length) {
    for (let i = idxEnd; i < spans.length; i++) {
       const distToSupport = spans.slice(idxEnd, i).reduce((a,b)=>a+b, 0);
       spanLoads[i].forEach(l => {
         if (l.type === 'moment') M_end -= l.mag; 
         else {
             const { totalForce, momentA } = getLoadIntegral(l);
             const xc = totalForce !== 0 ? momentA / totalForce : 0;
             const arm = distToSupport + xc;
             M_end -= totalForce * arm;
         }
       });
    }
  }

  const numNodes = idxEnd - idxStart + 1;
  const nodeMoments = new Array(spans.length + 1).fill(0);
  
  if (numNodes <= 1) {
    if (idxStart === idxEnd) nodeMoments[idxStart] = M_start + M_end;
  } else {
    const matrixSize = numNodes;
    const A = Array.from({ length: matrixSize }, () => Array(matrixSize).fill(0));
    const B = Array(matrixSize).fill(0);

    for (let k = 0; k < numNodes; k++) {
      const nodeIdx = idxStart + k;
      const supportType = supports[nodeIdx]; 
      const leftSpanIdx = nodeIdx - 1;
      const rightSpanIdx = nodeIdx;
      const phiL_load = (leftSpanIdx >= idxStart) ? calcPhi(spans[leftSpanIdx], spanLoads[leftSpanIdx]).phiR : 0;
      const phiR_load = (rightSpanIdx < idxEnd) ? calcPhi(spans[rightSpanIdx], spanLoads[rightSpanIdx]).phiL : 0;

      if (k === 0) {
        if (supportType === 'fixed') {
          A[k][k] = 2 * spans[rightSpanIdx];
          if (numNodes > 1) A[k][k+1] = spans[rightSpanIdx];
          B[k] = -6 * phiR_load;
        } else {
          A[k][k] = 1; B[k] = M_start;
        }
      } else if (k === numNodes - 1) {
        if (supportType === 'fixed') {
          const len = spans[leftSpanIdx];
          A[k][k-1] = len; A[k][k] = 2 * len;
          B[k] = -6 * phiL_load;
        } else {
          A[k][k] = 1; B[k] = M_end;
        }
      } else {
        A[k][k-1] = spans[leftSpanIdx];
        A[k][k] = 2 * (spans[leftSpanIdx] + spans[rightSpanIdx]);
        A[k][k+1] = spans[rightSpanIdx];
        B[k] = -6 * (phiL_load + phiR_load);
      }
    }
    const M_solutions = solveLinearSystem(A, B);
    for(let k=0; k<numNodes; k++) {
      nodeMoments[idxStart + k] = M_solutions[k];
    }
  }

  const shearData = []; 
  const momentData = [];
  let globalX = 0;

  for (let i = 0; i < spans.length; i++) {
    const len = spans[i];
    const sLoads = spanLoads[i];
    const ML = nodeMoments[i];
    const MR = nodeMoments[i+1];

    const keyPoints = new Set([0, len]);
    sLoads.forEach(l => { 
        keyPoints.add(l.pos); 
        if (l.type === 'moment') {
            keyPoints.add(Math.max(0, l.pos - 1e-6));
            keyPoints.add(Math.min(len, l.pos + 1e-6));
        } else if(l.type !== 'point') {
            keyPoints.add(l.pos + l.length);
        }
    });
    
    const steps = Math.max(50, Math.min(Math.ceil(len * 200), 2000));
    for(let k=0; k<=steps; k++) keyPoints.add(k * (len / steps));
    const sortedLx = Array.from(keyPoints).sort((a,b)=>a-b);

    let sumP=0, sumM=0;
    sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
    const Rb_s = sumM/len; const Ra_s = sumP - Rb_s;

    sortedLx.forEach(lx => {
        const gx = globalX + lx;
        const Qb = (MR - ML) / len;
        
        const Q_left = getSectionForceSimple(lx, sLoads, Ra_s, 'left').Q + Qb;
        const Q_right = getSectionForceSimple(lx, sLoads, Ra_s, 'right').Q + Qb;
        
        shearData.push({ x: gx, y: Q_left });
        if (Math.abs(Q_left - Q_right) > 1e-6) {
            shearData.push({ x: gx, y: Q_right });
        }
        
        const Ms = getSectionForceSimple(lx, sLoads, Ra_s).M;
        const Mb = ML + (MR - ML) * (lx / len);
        momentData.push({ x: gx, y: Ms + Mb });
    });
    globalX += len;
  }

  const deflectionData = [];
  const rawIntegration = [];
  let curTh = 0, curY = 0;
  rawIntegration.push({ x: 0, th: 0, y: 0 });

  for (let j = 0; j < momentData.length - 1; j++) {
      const p1 = momentData[j], p2 = momentData[j+1];
      const dx = p2.x - p1.x;
      if (dx < 1e-8) continue;
      
      const phi1 = -(p1.y * 1e6) / (props.E * props.I);
      const phi2 = -(p2.y * 1e6) / (props.E * props.I);
      const dTh = (phi1 + phi2) * 0.5 * dx * 1000;
      const dY = (curTh + (curTh + dTh)) * 0.5 * dx * 1000;
      curTh += dTh; curY += dY;
      rawIntegration.push({ x: p2.x, th: curTh, y: curY });
  }

  let C1 = 0, C2 = 0;
  const getRaw = (x) => {
      const match = rawIntegration.find(p => Math.abs(p.x - x) < 1e-4);
      if (match) return match;
      const low = rawIntegration.filter(p => p.x <= x).pop();
      const high = rawIntegration.find(p => p.x > x);
      if (!low || !high) return low || high || { th: 0, y: 0 };
      const r = (x - low.x) / (high.x - low.x);
      return { th: low.th + (high.th - low.th) * r, y: low.y + (high.y - low.y) * r };
  };

  const supportPoints = [];
  let tx = 0;
  supports.forEach((s, i) => {
      if (s !== 'free') supportPoints.push({ x: tx, type: s });
      if (i < spans.length) tx += spans[i];
  });

  if (supportPoints.length > 0) {
      const firstS = supportPoints[0];
      if (firstS.type === 'fixed') {
          const raw = getRaw(firstS.x);
          C1 = -raw.th;
          C2 = -raw.y - C1 * firstS.x;
      } else if (supportPoints.length >= 2) {
          const s1 = supportPoints[0], s2 = supportPoints[supportPoints.length - 1];
          const r1 = getRaw(s1.x), r2 = getRaw(s2.x);
          C1 = -(r2.y - r1.y) / (s2.x - s1.x);
          C2 = -r1.y - C1 * s1.x;
      } else {
          const r1 = getRaw(firstS.x);
          C1 = 0; C2 = -r1.y;
      }
  }

  rawIntegration.forEach(p => {
      deflectionData.push({ x: p.x, y: p.y + C1 * p.x + C2 });
  });

  const spanBounds = [];
  let sx = 0;
  for (let i = 0; i < spans.length; i++) {
    const ex = sx + spans[i];
    const sM_points = momentData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    const sQ_points = shearData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    const sD_points = deflectionData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    
    const maxM = Math.max(...sM_points.map(d => d.y)), minM = Math.min(...sM_points.map(d => d.y));
    const maxQ = Math.max(...sQ_points.map(d => d.y)), minQ = Math.min(...sQ_points.map(d => d.y));
    const maxD = Math.max(...sD_points.map(d => d.y)), minD = Math.min(...sD_points.map(d => d.y));

    spanBounds.push({
      spanIndex: i, 
      maxM, maxM_x: sM_points.find(d => d.y === maxM)?.x || sx,
      minM, minM_x: sM_points.find(d => d.y === minM)?.x || sx,
      maxQ, maxQ_x: sQ_points.find(d => d.y === maxQ)?.x || sx,
      minQ, minQ_x: sQ_points.find(d => d.y === minQ)?.x || sx,
      maxD, maxD_x: sD_points.find(d => d.y === maxD)?.x || sx,
      minD, minD_x: sD_points.find(d => d.y === minD)?.x || sx
    });
    sx = ex;
  }

  const reactions = [];
  validSupportIndices.forEach(idx => {
    let pos = 0; for(let k=0; k<idx; k++) pos += spans[k];
    let R_val = 0;
    
    if (idx > 0) {
        const i = idx - 1;
        const len = spans[i];
        const sLoads = spanLoads[i];
        let sumP=0, sumM=0;
        sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
        const Rb_simple = sumM/len; 
        
        const ML = nodeMoments[i]; const MR = nodeMoments[i+1];
        const Q_mom = (MR - ML) / len; 
        R_val += (Rb_simple - Q_mom);
    }

    if (idx < spans.length) {
        const i = idx;
        const len = spans[i];
        const sLoads = spanLoads[i];
        let sumP=0, sumM=0;
        sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
        const Rb_simple = sumM/len;
        const Ra_simple = sumP - Rb_simple;

        const ML = nodeMoments[i]; const MR = nodeMoments[i+1];
        const Q_mom = (MR - ML) / len;
        
        R_val += (Ra_simple + Q_mom);
    }
    
    reactions.push({ x: pos, val: R_val, label: String.fromCharCode(65+idx) });
  });

  const maxM_pos = Math.max(0, ...momentData.map(d=>d.y));
  const maxM_neg = Math.min(0, ...momentData.map(d=>d.y));

  return {
    shearData, momentData, deflectionData, spanBounds, reactions,
    raw: { spans, spanLoads, nodeMoments, supports },
    bounds: { 
      maxShear: Math.max(...shearData.map(d=>Math.abs(d.y))), maxShear_x: 0,
      maxM_pos, maxM_pos_x: momentData.find(d=>d.y===maxM_pos)?.x || 0,
      maxM_neg, maxM_neg_x: momentData.find(d=>d.y===maxM_neg)?.x || 0,
      maxDeflection: Math.max(...deflectionData.map(d=>Math.abs(d.y))), 
      maxDef_x: deflectionData.find(d=>Math.abs(d.y) === Math.max(...deflectionData.map(v=>Math.abs(v.y))))?.x || 0,
      maxSigma_pos: maxM_pos * 1e6 / props.Z,
      maxSigma_neg: maxM_neg * 1e6 / props.Z
    },
  };
}

function getResultAt(x, results, props, targetSpanIndex = -1) {
    if (!results.momentData) return {};
    if (results.raw) {
        const { spans, spanLoads, nodeMoments, supports } = results.raw;
        let currentX = 0, spanIndex = -1, localX = 0;

        if (targetSpanIndex !== -1 && targetSpanIndex >= 0 && targetSpanIndex < spans.length) {
            for(let k=0; k<targetSpanIndex; k++) currentX += spans[k];
            spanIndex = targetSpanIndex;
            localX = x - currentX;
            if(localX < 0 && localX > -0.001) localX = 0;
            if(localX > spans[spanIndex] && localX < spans[spanIndex] + 0.001) localX = spans[spanIndex];
        } else {
            for(let i=0; i<spans.length; i++) {
                if (x >= currentX - 1e-9 && x <= currentX + spans[i] + 1e-9) {
                    spanIndex = i; localX = x - currentX;
                    if(localX < 0) localX = 0; if(localX > spans[i]) localX = spans[i];
                    break;
                }
                currentX += spans[i];
            }
        }

        if (spanIndex !== -1) {
            const len = spans[spanIndex];
            const loads = spanLoads[spanIndex];
            const ML = nodeMoments[spanIndex];
            const MR = nodeMoments[spanIndex + 1];

            let sumP=0, sumM=0;
            loads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
            const Rb_simple = sumM/len;
            const Ra_simple = sumP - Rb_simple;

            const simpleRes = getSectionForceSimple(localX, loads, Ra_simple, 'right');
            const Qb = (MR - ML) / len;
            const Mb = ML + (MR - ML) * (localX / len);
            
            const totalQ = simpleRes.Q + Qb;
            let totalM = simpleRes.M + Mb;

            // Moment correction at ends
            const totalLen = spans.reduce((a,b)=>a+b, 0);
            const rightSupport = supports[supports.length - 1];
            if (Math.abs(x - totalLen) < 0.001 && ['free', 'pin', 'roller'].includes(rightSupport)) {
                let endMomentSum = 0;
                spanLoads[spans.length - 1].forEach(l => {
                    if (l.type === 'moment' && Math.abs(l.pos - spans[spans.length - 1]) < 0.001) endMomentSum += l.mag;
                });
                if (endMomentSum !== 0) totalM += (-endMomentSum);
            }

            let defVal = 0;
            if (results.deflectionData) {
                 const match = results.deflectionData.find(p => Math.abs(p.x - x) < 1e-4);
                 if (match) defVal = match.y;
                 else {
                     const low = results.deflectionData.filter(p => p.x <= x).pop();
                     const high = results.deflectionData.find(p => p.x > x);
                     if (low && high) {
                         defVal = low.y + (high.y - low.y) * ((x - low.x)/(high.x - low.x));
                     } else {
                         defVal = low ? low.y : (high ? high.y : 0);
                     }
                 }
            }
            return { Q: totalQ, M: totalM, deflection: defVal, sigma: Math.abs(totalM * 1e6 / props.Z) };
        }
    }
    return {};
}

function getSectionForceSimple(x, loads, Ra, side='left') {
  let Q = Ra, M = Ra * x;
  loads.forEach(l => {
    if (l.pos > x + EPS) return;
    if ((l.type === 'point' || l.type === 'moment') && Math.abs(l.pos - x) < EPS && side === 'left') return;
    let endPos = l.pos + l.length, effectiveLen = Math.max(0, Math.min(x, endPos) - l.pos);
    if (effectiveLen < EPS && l.type !== 'point' && l.type !== 'moment') return;
    let pLoad = { ...l, length: effectiveLen };
    if (l.type === 'trapezoid') pLoad.magEnd = l.mag + (l.magEnd - l.mag) * effectiveLen / l.length;
    
    if (l.type === 'moment') {
        M += l.mag; 
    } else {
        const r = getLoadIntegral(pLoad);
        Q -= r.totalForce; M -= (x * r.totalForce - r.momentA);
    }
  });
  return { Q, M };
}

function getLoadIntegral(l) {
  if (l.type === 'point') return { totalForce: l.mag, momentA: l.mag * l.pos };
  if (l.type === 'moment') return { totalForce: 0, momentA: l.mag }; 
  const w1=l.mag, w2=l.type==='trapezoid'?l.magEnd:l.mag, L=l.length;
  if (L <= 0) return { totalForce: 0, momentA: 0 };
  const F = L*(w1+w2)/2, distC = (w1+w2)===0 ? L/2 : (L/3) * (w1 + 2*w2) / (w1+w2); 
  return { totalForce: F, momentA: F * (l.pos + distC) };
}

function calcPhi(L, loads) {
  let phiL = 0, phiR = 0; 
  const stepsPerMeter = 1000;
  const N = Math.min(Math.max(50, Math.ceil(L * stepsPerMeter)), 10000); 
  const dx = L/N;
  let sumP=0, sumM=0; loads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
  const Rb = sumM/L, Ra = sumP - Rb;
  for(let i=0; i<N; i++) {
    const x = (i+0.5)*dx, M = getSectionForceSimple(x, loads, Ra).M;
    phiL += (M * (L-x)/L) * dx; phiR += (M * x/L) * dx;
  }
  return { phiL, phiR };
}

function solveLinearSystem(A, B) {
  const n = B.length;
  for (let i = 0; i < n; i++) {
    let maxEl = Math.abs(A[i][i]), maxRow = i;
    for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > maxEl) { maxEl = Math.abs(A[k][i]); maxRow = k; }
    for (let k = i; k < n; k++) [A[maxRow][k], A[i][k]] = [A[i][k], A[maxRow][k]];
    [B[maxRow], B[i]] = [B[i], B[maxRow]];
    for (let k = i + 1; k < n; k++) {
      const c = -A[k][i] / A[i][i];
      for (let j = i; j < n; j++) A[k][j] = (i === j ? 0 : A[k][j] + c * A[i][j]);
      B[k] += c * B[i];
    }
  }
  const x = new Array(n).fill(0);
  for (let i = n - 1; i > -1; i--) {
    let sum = 0; for (let k = i + 1; k < n; k++) sum += A[i][k] * x[k];
    x[i] = (B[i] - sum) / A[i][i];
  }
  return x;
}

function generateEmptyResult() {
  return { shearData:[], momentData:[], deflectionData:[], poiResults:[], spanBounds:[], reactions:[], bounds:{ maxShear:0, maxM_pos:0, maxM_neg:0, maxDeflection:0, maxSigma_pos:0, maxSigma_neg:0 } };
}

// --------------------------------------------------------
// Visual Components
// --------------------------------------------------------
function SectionProfileView({ props }) {
  const { shape, dims, axis, matType } = props;
  const size = 100, scale = 0.8;
  const cx = size / 2, cy = size / 2;
  let pathD = "";
  
  if (matType === 'manual') {
      const H=s(200), B=s(100), t1=s(6), t2=s(8);
      pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)/2} v ${H-2*t2} h ${(B-t1)/2} v ${t2} h ${-B} v ${-t2} h ${(B-t1)/2} v ${-(H-2*t2)} h ${-(B-t1)/2} z`;
      return <svg width="100%" height="100%" viewBox="0 0 100 100"><path d={pathD} fill="#e2e8f0" stroke="#94a3b8" strokeWidth="1.5" strokeDasharray="3" /><text x={50} y={50} textAnchor="middle" fontSize="10" fill="#64748b" dominantBaseline="middle">Manual</text></svg>;
  }

  if (!dims.H) return null;
  const maxDim = Math.max(dims.H, dims.B);
  function s(v) { return (v / maxDim) * size * scale; }
  
  if (matType === 'concrete') {
    const w = s(dims.B), h = s(dims.H); 
    pathD = `M ${cx-w/2} ${cy-h/2} h ${w} v ${h} h ${-w} z`;
    return (
      <svg width="100%" height="100%" viewBox="0 0 100 100">
        <path d={pathD} fill="#cbd5e1" stroke="#475569" strokeWidth="1.5" />
        <text x={cx} y={cy+h/2+10} textAnchor="middle" fontSize="8" fill="#475569">b={dims.B}</text>
        <text x={cx+w/2+2} y={cy} textAnchor="start" fontSize="8" fill="#475569">D={dims.H}</text>
      </svg>
    );
  } else {
    const H = s(dims.H), B = s(dims.B), t1 = s(dims.t1), t2 = s(dims.t2), C = s(dims.C_lip || 0);
    if (shape === 'H') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)/2} v ${H-2*t2} h ${(B-t1)/2} v ${t2} h ${-B} v ${-t2} h ${(B-t1)/2} v ${-(H-2*t2)} h ${-(B-t1)/2} z`;
    else if (shape === 'Channel') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)} v ${H-2*t2} h ${B-t1} v ${t2} h ${-B} z`;
    else if (shape === 'Angle') pathD = `M ${cx-B/2} ${cy-H/2} v ${H} h ${B} v ${-t2} h ${-(B-t1)} v ${-(H-t2)} z`;
    else if (shape === 'LipChannel') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${C} h ${-t2} v ${-(C-t2)} h ${-(B-t1-t2)} v ${H-2*t2} h ${B-t1-t2} v ${-(C-t2)} h ${t2} v ${C} h ${-B} z`;
    else if (shape.includes('SheetPile')) {
        const dH = H, dB = B, dt = t1;
        pathD = `M ${cx-dB/2} ${cy-dH/2} v ${dH} h ${dB} v ${-dH} h ${-dt} v ${dH-dt} h ${-(dB-2*dt)} v ${-(dH-dt)} z`;
    } else if (shape === 'SquarePipe') {
        const dH = H, dB = B, dt = t1;
        pathD = `M ${cx-dB/2} ${cy-dH/2} h ${dB} v ${dH} h ${-dB} z M ${cx-(dB-2*dt)/2} ${cy-(dH-2*dt)/2} v ${dH-2*dt} h ${dB-2*dt} v ${-(dH-2*dt)} z`;
    }
  }
  return <svg width="100%" height="100%" viewBox="0 0 100 100"><path d={pathD} fill="#cbd5e1" stroke="#475569" strokeWidth="1.5" fillRule="evenodd" transform={axis === 'weak' ? `rotate(90, ${cx}, ${cy})` : ''} /></svg>;
}

function ResultBox({ label, val, x, unit, sub, color }) {
  return (
    <div className="bg-white p-3 rounded-lg border shadow-sm">
      <div className="text-[10px] text-slate-400 uppercase font-bold">{label}</div>
      <div className={`text-lg font-bold ${color}`}>{val?.toFixed(2)} <span className="text-xs text-slate-400">{unit}</span></div>
      <div className="flex gap-2 text-[10px]">
        {x !== undefined && <span className="bg-slate-100 px-1 rounded inline-block text-slate-500">x={x.toFixed(3)}m</span>}
        {sub && <span className="bg-slate-100 px-1 rounded inline-block text-slate-500">{sub}</span>}
      </div>
    </div>
  );
}

// --------------------------------------------------------
// PoiTable & PoiInput
// --------------------------------------------------------

function PoiInput({ id, globalX, rangeStart, onUpdate }) {
  const [val, setVal] = useState((globalX - rangeStart).toFixed(3));
  
  useEffect(() => {
    setVal((globalX - rangeStart).toFixed(3));
  }, [globalX, rangeStart]);

  const handleBlur = () => {
    const num = parseFloat(val);
    if (!isNaN(num) && num >= 0) {
      onUpdate(id, rangeStart + num);
    } else {
      setVal((globalX - rangeStart).toFixed(3));
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') e.target.blur();
  };

  return (
    <input 
      type="text" 
      className="w-12 p-0.5 text-center border border-blue-300 rounded text-blue-700 font-bold bg-white focus:ring-2 focus:ring-blue-200 outline-none"
      value={val}
      onChange={(e) => setVal(e.target.value)}
      onBlur={handleBlur}
      onKeyDown={handleKeyDown}
      onClick={(e) => e.stopPropagation()}
    />
  );
}

function PoiTable({ finalPoiData, userPoi, setUserPoi, totalLength, spans, results, sectionProps }) {
  const addUserPoint = (globalX) => {
      const newId = Date.now();
      setUserPoi([...userPoi, { id: newId, x: globalX }]);
  };

  const updateUserPoint = (id, newGlobalX) => {
      setUserPoi(userPoi.map(p => p.id === id ? { ...p, x: newGlobalX } : p));
  };

  const removeUserPoint = (id) => {
      setUserPoi(userPoi.filter(p => p.id !== id));
  };

  const spanRanges = useMemo(() => {
    let currentX = 0; return spans.map(len => { const range = { start: currentX, end: currentX + len }; currentX += len; return range; });
  }, [spans]);

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-2"><h3 className="text-sm font-bold text-slate-600">着目点詳細 (スパン別)</h3></div>
      {spanRanges.map((range, sIdx) => {
        const spanPoints = finalPoiData.filter(p => p.x >= range.start - 1e-4 && p.x <= range.end + 1e-4);
        return (
          <div key={sIdx} className="border rounded-lg overflow-hidden bg-white shadow-sm">
            <div className="bg-slate-100 px-3 py-1.5 text-xs font-bold text-slate-600 flex justify-between items-center">
                <span>径間 {sIdx + 1} ({String.fromCharCode(65+sIdx)} - {String.fromCharCode(65+sIdx+1)})</span>
                <div className="flex items-center gap-3">
                    <span className="font-normal opacity-70">スパン長: {spans[sIdx].toFixed(2)}m</span>
                    <button onClick={() => addUserPoint(range.start)} className="flex items-center gap-1 px-2 py-0.5 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors"><Plus className="w-3 h-3"/> 追加</button>
                </div>
            </div>
            <table className="w-full text-[11px] text-left">
              <thead className="bg-slate-50 text-slate-400 border-b"><tr><th className="p-2 w-24">Local x (m)</th><th className="p-2">Q (kN)</th><th className="p-2">M (kN·m)</th><th className="p-2">σ (N/mm²)</th><th className="p-2">δ (mm)</th><th className="w-8"></th></tr></thead>
              <tbody className="divide-y">
                {spanPoints.map((p) => {
                  const localX = Math.max(0, Math.min(spans[sIdx], p.x - range.start));
                  const isUser = p.type === 'user';
                  const val = getResultAt(p.x, results, sectionProps, sIdx);
                  return (
                    <tr key={p.id} className={isUser ? "bg-blue-50/20" : "hover:bg-slate-50"}>
                      <td className="p-2">
                          <div className="flex items-center gap-1">
                              {isUser ? <PoiInput id={p.id} globalX={p.x} rangeStart={range.start} onUpdate={updateUserPoint} /> 
                              : <div className="flex items-center gap-2"><span className="font-mono text-slate-500 w-12">{localX.toFixed(3)}</span><span className="text-[9px] px-1 bg-slate-200 rounded text-slate-500">Auto</span></div>}
                              {isUser && <span className="text-[9px] text-slate-300">m</span>}
                          </div>
                      </td>
                      <td className="p-2 font-mono text-slate-600">{val?.Q?.toFixed(2)}</td>
                      <td className="p-2 font-mono text-slate-600">{val?.M?.toFixed(2)}</td>
                      <td className="p-2 font-mono text-slate-700">{val?.sigma?.toFixed(1)}</td>
                      <td className="p-2 font-mono text-blue-600 font-bold">{val?.deflection?.toFixed(2)}</td>
                      <td className="p-2 text-right">{isUser && (<button onClick={() => removeUserPoint(p.id)}><X className="w-3 h-3 text-slate-300 hover:text-red-500" /></button>)}</td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        );
      })}
    </div>
  );
}

// --------------------------------------------------------
// AdvancedVisualizer
// --------------------------------------------------------
function AdvancedVisualizer({ spans, supports, totalLength, loads, results, forceWidth, userPoi }) {
  const containerRef = useRef(null);
  const [width, setWidth] = useState(forceWidth || 600);
  
  useEffect(() => {
    if (forceWidth) { setWidth(forceWidth); return; }
    if(containerRef.current) setWidth(containerRef.current.clientWidth);
    const h = () => { if(containerRef.current) setWidth(containerRef.current.clientWidth); };
    window.addEventListener('resize', h); return () => window.removeEventListener('resize', h);
  }, [forceWidth]);

  const height = 950, padding = { left: 50, right: 50, top: 40 };
  const scaleX = (v) => padding.left + (v / totalLength) * (width - padding.left - padding.right);
  const beamY = 120, sfdY = 360, bmdY = 610, defY = 860, graphH = 70;
  
  const { maxShear, maxM_pos, maxM_neg, maxDeflection } = results.bounds;
  const maxM = Math.max(Math.abs(maxM_pos), Math.abs(maxM_neg), 1), maxD = Math.max(Math.abs(maxDeflection), 0.1), maxQ = Math.max(Math.abs(maxShear), 1);
  const syQ = v => sfdY - (v/maxQ)*(graphH/2), syM = v => bmdY + (v/maxM)*(graphH/2), syD = v => defY + (v/maxD)*(graphH/2);
  const maxLoadMag = Math.max(...loads.map(l => Math.max(Math.abs(l.mag), Math.abs(l.magEnd || 0))), 1);
  const loadHScale = 40 / maxLoadMag;

  const collectPoints = (dataArr, boundsArr, scaleYFunc, type) => {
      const points = [];
      if (!dataArr || dataArr.length === 0) return [];
      points.push({ xVal: dataArr[0].x, val: dataArr[0].y });
      points.push({ xVal: dataArr[dataArr.length-1].x, val: dataArr[dataArr.length-1].y });
      boundsArr.forEach(sb => {
          if (type === 'M') {
             points.push({ xVal: sb.maxM_x, val: sb.maxM });
             points.push({ xVal: sb.minM_x, val: sb.minM });
          } else if (type === 'Q') {
              points.push({ xVal: sb.maxQ_x, val: sb.maxQ });
              points.push({ xVal: sb.minQ_x, val: sb.minQ });
          } else { 
              points.push({ xVal: sb.maxD_x, val: sb.maxD });
              points.push({ xVal: sb.minD_x, val: sb.minD });
          }
      });
      // Add User POI Values
      if (userPoi && userPoi.length > 0) {
          userPoi.forEach(up => {
              const closest = dataArr.reduce((prev, curr) => Math.abs(curr.x - up.x) < Math.abs(prev.x - up.x) ? curr : prev);
              points.push({ xVal: up.x, val: closest.y });
          });
      }
      const uniquePoints = [];
      points.forEach(p => {
          const exists = uniquePoints.some(ep => Math.abs(ep.xVal - p.xVal) < 0.001 && Math.abs(ep.val - p.val) < 0.01);
          if (!exists) uniquePoints.push({ x: scaleX(p.xVal), y: scaleYFunc(p.val), val: p.val, xVal: p.xVal, unit: type === 'M' ? 'kN·m' : (type === 'Q' ? 'kN' : 'mm') });
      });
      return uniquePoints;
  };

  const calculateLabelLayout = (rawPoints, baseY) => {
      let sorted = [...rawPoints].sort((a, b) => a.x - b.x);
      const placedRects = []; const results = [];
      const boxW = 120, boxH = 16;
      sorted.forEach(p => {
          const originY = p.y;
          const isVisuallyBelow = originY > baseY + 1; 
          let goUp = isVisuallyBelow ? false : true;
          const offsetUp = 10, offsetDown = 12; 
          let candY = originY + (goUp ? -offsetUp : offsetDown);
          const shiftStep = goUp ? -17 : 17; 
          for (let k = 0; k < 15; k++) { 
              let collision = false;
              for (const r of placedRects) if (Math.abs(p.x - r.x) < boxW && Math.abs(candY - r.y) < boxH) { collision = true; break; }
              if (!collision) break; 
              candY += shiftStep;
          }
          placedRects.push({ x: p.x, y: candY }); 
          const showLine = Math.abs(candY - originY) > 25;
          results.push({ ...p, finalY: candY, originY, showLine });
      });
      return results;
  };

  const sfdLabels = calculateLabelLayout(collectPoints(results.shearData, results.spanBounds, syQ, 'Q'), sfdY); 
  const bmdLabels = calculateLabelLayout(collectPoints(results.momentData, results.spanBounds, syM, 'M'), bmdY); 
  const defLabels = calculateLabelLayout(collectPoints(results.deflectionData, results.spanBounds, syD, 'D'), defY); 

  const loadTextOccupied = useRef([]);
  loadTextOccupied.current = [];
  const getAdjustedLoadTextY = (x, yBase, isBottom) => {
      let y = yBase, shift = isBottom ? 13 : -13;
      for(let i=0; i<5; i++) {
         let collision = false;
         for (let l of loadTextOccupied.current) if (Math.abs(x - l.x) < 40 && Math.abs(y - l.y) < 12) { collision = true; break; }
         if (!collision) break;
         y += shift; 
      }
      loadTextOccupied.current.push({ x, y }); return y;
  };

  return (
    <div ref={containerRef} className="w-full select-none">
      <svg width={width} height={height} className="overflow-visible">
        <defs><marker id="arrow" markerWidth="8" markerHeight="5" refX="7.5" refY="2.5" orient="auto"><polygon points="0 0, 8 2.5, 0 5" fill={COLORS.load} /></marker></defs>
        <g key={`${totalLength}-${spans.join('-')}`}>
          {(() => {
            const guidePoints = new Set([0, totalLength]);
            let cx = 0; spans.forEach(s => { cx += s; guidePoints.add(cx); });
            loads.forEach(l => { guidePoints.add(l.pos); if(l.type !== 'point') guidePoints.add(l.pos + l.length); });
            return Array.from(guidePoints).map((gx, i) => <line key={i} x1={scaleX(gx)} y1={beamY+20} x2={scaleX(gx)} y2={height-20} stroke={COLORS.guide} strokeWidth="0.5" strokeDasharray="3" opacity="0.3" />);
          })()}

          {spans.map((len, i) => {
             let sx_val = 0; for(let k=0; k<i; k++) sx_val += spans[k];
             const x1 = scaleX(sx_val), x2 = scaleX(sx_val + len);
             return (
               <g key={`dim-span-${i}`}>
                 <text x={(x1+x2)/2} y={beamY + 45} textAnchor="middle" fontSize="10" fill={COLORS.dim}>{len}m</text>
                 <line x1={x1} y1={beamY + 35} x2={x2} y2={beamY + 35} stroke={COLORS.dim} strokeWidth="0.8" />
                 <line x1={x1} y1={beamY + 32} x2={x1} y2={beamY + 38} stroke={COLORS.dim} strokeWidth="0.8" />
                 <line x1={x2} y1={beamY + 32} x2={x2} y2={beamY + 38} stroke={COLORS.dim} strokeWidth="0.8" />
               </g>
             );
          })}
          <line x1={scaleX(0)} y1={beamY} x2={scaleX(totalLength)} y2={beamY} stroke={COLORS.beam} strokeWidth="4" />
          
          {supports.map((type, i) => {
            let cx = 0; for(let k=0;k<i;k++) cx += (k<spans.length?spans[k]:0);
            const x = scaleX(cx); if (type === 'free') return null;
            let icon = (type === 'fixed') ? <line x1={x} y1={beamY-15} x2={x} y2={beamY+15} stroke={COLORS.support} strokeWidth="6"/> : <polygon points={`${x},${beamY} ${x-6},${beamY+10} ${x+6},${beamY+10}`} fill="none" stroke={COLORS.support} strokeWidth="2"/>;
            return <g key={`supp-label-${i}`}>{icon}<text x={x} y={beamY + 25} textAnchor="middle" fontSize="11" fontWeight="bold" fill={COLORS.support}>{String.fromCharCode(65 + i)}</text></g>;
          })}

          {loads.map(l => {
             const x = scaleX(l.pos);
             const isNeg = l.mag < 0;
             const pointOffset = (l.type === 'point') ? 20 : 0;
             const h1 = Math.abs(l.mag) * loadHScale + pointOffset;
             const currentBeamY = isNeg ? beamY : beamY; 
             const yS = isNeg ? currentBeamY + h1 : currentBeamY - h1;
             const yE = isNeg ? currentBeamY + 5 : currentBeamY - 5;
             const textY = isNeg ? currentBeamY + h1 + 15 : currentBeamY - h1 - 15;

             if(l.type==='point') {
                return <g key={l.id}><line x1={x} y1={yS} x2={x} y2={yE} stroke={COLORS.load} strokeWidth="2" markerEnd="url(#arrow)"/><text x={x} y={textY} textAnchor="middle" fontSize="10" fill={COLORS.load}>{l.mag}kN</text></g>;
             } else if (l.type === 'moment') {
                return <g key={l.id}><circle cx={x} cy={beamY-20} r="16" fill="none" stroke={COLORS.load} strokeWidth="2"/><text x={x} y={beamY-35} textAnchor="middle" fontSize="10" fill={COLORS.load}>{l.mag}</text></g>;
             } else {
                const x2 = scaleX(l.pos+l.length);
                return <g key={l.id}><rect x={x} y={beamY-30} width={x2-x} height="30" fill={COLORS.loadPolygon} /><text x={x} y={beamY-35} textAnchor="start" fontSize="10" fill={COLORS.load}>{l.mag}</text></g>;
             }
          })}

          {/* SFD */}
          <g>
            <text x={10} y={sfdY - 75} fontSize="10" fontWeight="bold" fill={COLORS.shearLine}>せん断力図 (SFD) [kN]</text>
            <line x1={scaleX(0)} y1={sfdY} x2={scaleX(totalLength)} y2={sfdY} stroke="#cbd5e1" strokeDasharray="2"/>
            <path d={`M ${scaleX(0)} ${sfdY} ` + results.shearData.map(p=>`L ${scaleX(p.x)} ${syQ(p.y)}`).join(' ') + ` L ${scaleX(totalLength)} ${sfdY}`} fill={COLORS.shearFill} opacity="0.6"/><path d={`M ${scaleX(0)} ${syQ(results.shearData[0]?.y||0)} ` + results.shearData.map(p=>`L ${scaleX(p.x)} ${syQ(p.y)}`).join(' ')} fill="none" stroke={COLORS.shearLine} strokeWidth="1.5"/>
            {sfdLabels.map((lbl, i) => (
                <g key={i}>
                    {lbl.showLine && <line x1={lbl.x} y1={lbl.originY} x2={lbl.x} y2={lbl.finalY} stroke={COLORS.shearLine} strokeWidth="0.5" opacity="0.5" />}
                    <text x={lbl.x} y={lbl.finalY} textAnchor="middle" fontSize="10" fill={COLORS.shearLine} fontWeight="bold">{lbl.val.toFixed(2)}</text>
                </g>
            ))}
          </g>

          {/* BMD */}
          <g>
            <text x={10} y={bmdY - 75} fontSize="10" fontWeight="bold" fill={COLORS.momentLine}>曲げモーメント図 (BMD) [kN·m]</text>
            <line x1={scaleX(0)} y1={bmdY} x2={scaleX(totalLength)} y2={bmdY} stroke="#cbd5e1" strokeDasharray="2"/>
            <path d={`M ${scaleX(0)} ${bmdY} ` + results.momentData.map(p=>`L ${scaleX(p.x)} ${syM(p.y)}`).join(' ') + ` L ${scaleX(totalLength)} ${bmdY}`} fill={COLORS.momentFill} opacity="0.6"/><path d={`M ${scaleX(0)} ${syM(results.momentData[0]?.y||0)} ` + results.momentData.map(p=>`L ${scaleX(p.x)} ${syM(p.y)}`).join(' ')} fill="none" stroke={COLORS.momentLine} strokeWidth="1.5"/>
            {bmdLabels.map((lbl, i) => (
                <g key={i}>
                    {lbl.showLine && <line x1={lbl.x} y1={lbl.originY} x2={lbl.x} y2={lbl.finalY} stroke={COLORS.momentLine} strokeWidth="0.5" opacity="0.5" />}
                    <text x={lbl.x} y={lbl.finalY} textAnchor="middle" fontSize="10" fill={COLORS.momentLine} fontWeight="bold">{lbl.val.toFixed(2)}</text>
                </g>
            ))}
          </g>

          {/* Deflection */}
          <g>
            <text x={10} y={defY - 75} fontSize="10" fontWeight="bold" fill={COLORS.deflLine}>変位図 (たわみ) [mm]</text>
            <line x1={scaleX(0)} y1={defY} x2={scaleX(totalLength)} y2={defY} stroke="#cbd5e1" strokeDasharray="2"/>
            <path d={`M ${scaleX(0)} ${defY} ` + results.deflectionData.map(p=>`L ${scaleX(p.x)} ${syD(p.y)}`).join(' ') + ` L ${scaleX(totalLength)} ${defY}`} fill={COLORS.deflFill} opacity="0.4"/><path d={`M ${scaleX(0)} ${syD(results.deflectionData[0]?.y||0)} ` + results.deflectionData.map(p=>`L ${scaleX(p.x)} ${syD(p.y)}`).join(' ')} fill="none" stroke={COLORS.deflLine} strokeWidth="1.5"/>
            {defLabels.map((lbl, i) => (
                <g key={i}>
                    {lbl.showLine && <line x1={lbl.x} y1={lbl.originY} x2={lbl.x} y2={lbl.finalY} stroke={COLORS.deflLine} strokeWidth="0.5" opacity="0.5" />}
                    <text x={lbl.x} y={lbl.finalY} textAnchor="middle" fontSize="10" fill={COLORS.deflLine} fontWeight="bold">{lbl.val.toFixed(2)}</text>
                </g>
            ))}
          </g>
        </g>
      </svg>
    </div>
  );
}

// Reactアプリのマウント
const root = createRoot(document.getElementById('root'));
root.render(<App />);

</script>
</body>
</html>
