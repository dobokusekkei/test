<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>構造計算アプリケーション v21.30</title>
<script src="https://cdn.tailwindcss.com"></script>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom/server": "https://esm.sh/react-dom@18.2.0/server",
    "lucide-react": "https://esm.sh/lucide-react@0.294.0"
  }
}
</script>
<script src="https://unpkg.com/@babel/standalone@7.23.9/babel.min.js"></script>
<style>
    body { font-family: 'Helvetica Neue', Arial, sans-serif; }
    @media print {
        .no-print { display: none !important; }
        body { padding: 0; background: white; }
        .container { width: 100%; max-width: none; box-shadow: none; padding: 0; }
    }
    /* 数式用スタイル - Beautiful Math CSS */
    .math-display { 
        font-family: 'Times New Roman', Times, serif; 
        font-style: italic; 
        text-align: center;
        background-color: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 0.5rem;
        padding: 1rem;
        margin: 1rem 0;
        overflow-x: auto;
        font-size: 1.1em;
        line-height: 2;
    }
    .math-inline {
        font-family: 'Times New Roman', Times, serif; 
        font-style: italic;
        padding: 0 0.1em;
    }
    .fraction { 
        display: inline-flex; 
        flex-direction: column; 
        align-items: center; 
        vertical-align: middle; 
        margin: 0 0.3em; 
        font-size: 0.9em;
    }
    .fraction > span:first-child { 
        border-bottom: 1px solid #334155; 
        padding: 0.1em 0.2em; 
        display: block;
        width: 100%;
        text-align: center;
    }
    .fraction > span:last-child { 
        padding-top: 0.1em;
        display: block;
        width: 100%;
        text-align: center;
    }
    .sub { font-size: 0.7em; vertical-align: sub; margin-left: 0.05em; font-style: normal; }
    .sup { font-size: 0.7em; vertical-align: super; margin-left: 0.05em; font-style: normal; }
    .op { margin: 0 0.3em; font-style: normal; }
    .func { font-style: normal; margin-right: 0.2em; }
    .integral { font-size: 1.5em; vertical-align: middle; margin-right: 0.1em; font-style: normal; }
</style>
</head>
<body class="bg-slate-50 text-slate-800">
<div id="root"></div>

<script type="text/babel" data-type="module">
import React, { useState, useMemo, useEffect, useRef } from 'react';
import { createRoot } from 'react-dom/client';
import { createPortal } from 'react-dom';
import { renderToStaticMarkup } from 'react-dom/server';
import { Plus, Trash2, Activity, Settings, List, X, Layers, ChevronDown, ArrowRight, RotateCw, AlertTriangle, Save, FolderOpen, Printer, Edit3, HelpCircle, History, FileDown, Upload, ExternalLink } from 'lucide-react';

// --- 定数 ---
const INITIAL_SPAN = "6.0";
const RESOLUTION = 400; // 描画解像度（SVG用）
const E_STEEL = 205000; // N/mm2
const EPS = 1e-9; 
const COLORS = {
  beam: '#334155', support: '#475569', load: '#ef4444',
  loadPolygon: 'rgba(239, 68, 68, 0.2)',
  shearFill: '#fcd34d', shearLine: '#d97706',
  momentFill: '#86efac', momentLine: '#16a34a',
  deflFill: '#bfdbfe', deflLine: '#2563eb',
  text: '#1e293b', dim: '#64748b',
  guide: '#94a3b8'
};

const BEAM_TYPES = {
  simple: { label: '単純梁 (1径間)', icon: 'I', hint: 'スパン長を入力 (例: 6.0)' },
  fixed: { label: '両端固定梁 (1径間)', icon: 'H', hint: 'スパン長を入力 (例: 6.0)' },
  cantilever: { label: '片持ち梁 (1径間)', icon: 'L', hint: 'スパン長を入力 (例: 3.0)' },
  overhang_one: { label: '単純梁 + 片側張り出し', icon: 'P', hint: '中央, 張り出し長 (例: 6.0, 2.0)' },
  overhang_both: { label: '単純梁 + 両側張り出し', icon: 'W', hint: '左張出, 中央, 右張出 (例: 2.0, 6.0, 2.0)' },
  continuous2: { label: '2径間連続梁', icon: 'M', hint: 'L1, L2 (例: 5.0, 5.0)' },
  continuous2_overhang: { label: '2径間 + 片側張り出し', icon: 'M', hint: '径間1, 径間2, 張出 (例: 5.0, 5.0, 2.0)' },
  continuous3: { label: '3径間連続梁', icon: 'C', hint: 'L1, L2, L3 (例: 5.0, 5.0, 5.0)' },
};

function normalizeText(text) {
  return text.replace(/[０-９．，]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/、/g, ',');
}

/**
 * 鋼材特性を取得する関数
 * データ(db)が空の場合でもエラーにならないようガード処理を追加
 */
function getSteelProps(shape, name, axis, db) {
  // dbがundefinedの場合は空オブジェクトとして扱う
  const safeDb = db || {};
  const props = safeDb[name];
  
  // propsが見つからない場合は安全なデフォルト値を返す(NaNエラー防止)
  if (!props) {
    return { H:0, B:0, t1:0, t2:0, I:1, Z:1, A:0, w:0, label: (name || '未選択') + ' (No Data)' };
  }

  // 寸法情報の取得（描画用）
  let H = 0, B = 0, t1 = 0, t2 = 0, C_lip = 0;
    
  if (shape.includes('SheetPile')) {
    H = props.H; B = props.B; t1 = props.t; t2 = props.t;
  } else if (shape === 'SquarePipe') {
    // Square-100x100x3.2 -> H=100, B=100, t1=3.2
    const nums = name.replace(/^Square-/, '').split('x').map(Number);
    [H, B, t1] = nums; t2 = t1;
  } else {
    const nums = name.replace(/^[A-Z]-/, '').split('x').map(Number);
    if (shape === 'H' || shape === 'Channel') { [H, B, t1, t2] = nums; } 
    else if (shape === 'LipChannel') { [H, B, C_lip, t1] = nums; t2 = t1; } 
    else if (shape === 'Angle') { [H, B, t1] = nums; t2 = t1; }
  }

  // 軸に応じた値を返す (I, Zは mm単位に換算)
  let I, Z;
  if (axis === 'strong') {
    I = props.Ix * 10000; 
    Z = props.Zx * 1000;
  } else {
    I = props.Iy * 10000; 
    Z = props.Zy * 1000;
  }

  return { H, B, t1, t2, C_lip, I, Z, A: props.A, w: props.w };
}

// ==========================================
// Help Modal / User Manual
// ==========================================
function HelpModal({ onClose, manualData }) {
    // manualDataが空の場合のフォールバック
    const sections = manualData || [];
    
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-3xl max-h-[85vh] overflow-hidden flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b flex justify-between items-center bg-slate-50">
                    <h2 className="text-lg font-bold flex items-center gap-2 text-slate-800">
                        <HelpCircle className="w-5 h-5 text-blue-600" />
                        ユーザーマニュアル
                    </h2>
                    <button onClick={onClose} className="p-1 hover:bg-slate-200 rounded-full transition-colors">
                        <X className="w-5 h-5 text-slate-500" />
                    </button>
                </div>
                <div className="p-6 overflow-y-auto text-sm text-slate-700 leading-relaxed space-y-6">
                    {sections.length === 0 && <p className="text-center text-slate-400">マニュアルデータを読み込めませんでした。</p>}
                    {sections.map((section, idx) => (
                        <section key={idx}>
                            <h3 className="font-bold text-slate-900 border-l-4 border-blue-500 pl-2 mb-2">{section.title}</h3>
                            {section.content && <p>{section.content}</p>}
                            
                            {section.type === 'list' && section.items && (
                                <ul className="list-disc pl-5 space-y-1">
                                    {section.items.map((item, i) => (
                                        <li key={i} dangerouslySetInnerHTML={{ __html: item }} />
                                    ))}
                                </ul>
                            )}
                            
                            {section.type === 'grid' && section.items && (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {section.items.map((item, i) => (
                                        <div key={i} className="bg-slate-50 p-3 rounded border">
                                            <span className="font-bold block text-blue-700 mb-1">{item.label}</span>
                                            {item.desc}
                                        </div>
                                    ))}
                                </div>
                            )}

                            {section.extraHtml && (
                                <div dangerouslySetInnerHTML={{ __html: section.extraHtml }} />
                            )}
                            
                            {section.type === 'custom' && section.htmlContent && (
                                <div dangerouslySetInnerHTML={{ __html: section.htmlContent }} />
                            )}
                        </section>
                    ))}
                </div>
                <div className="p-4 border-t bg-slate-50 text-right">
                    <button onClick={onClose} className="px-4 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 transition-colors">閉じる</button>
                </div>
            </div>
        </div>
    );
}

// ==========================================
// Version History Modal
// ==========================================
function VersionHistoryModal({ onClose, historyData }) {
    const history = historyData || [];
    
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b flex justify-between items-center bg-slate-50">
                    <h2 className="text-lg font-bold flex items-center gap-2 text-slate-800">
                        <History className="w-5 h-5 text-blue-600" />
                        更新履歴
                    </h2>
                    <button onClick={onClose} className="p-1 hover:bg-slate-200 rounded-full transition-colors">
                        <X className="w-5 h-5 text-slate-500" />
                    </button>
                </div>
                <div className="p-0 overflow-y-auto max-h-[60vh]">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-slate-100 text-slate-500 font-medium">
                            <tr>
                                <th className="p-3 border-b">Version</th>
                                <th className="p-3 border-b">Date</th>
                                <th className="p-3 border-b">Description</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y">
                            {history.length === 0 && <tr><td colSpan="3" className="p-4 text-center text-slate-400">履歴データなし</td></tr>}
                            {history.map((h, i) => (
                                <tr key={i} className="hover:bg-slate-50">
                                    <td className="p-3 font-mono font-bold text-blue-600 align-top">{h.ver}</td>
                                    <td className="p-3 text-slate-500 text-xs align-top whitespace-nowrap">{h.date}</td>
                                    <td className="p-3 text-slate-700 align-top">{h.desc}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
                <div className="p-4 border-t bg-slate-50 text-right">
                    <button onClick={onClose} className="px-4 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 transition-colors">閉じる</button>
                </div>
            </div>
        </div>
    );
}

// PoiInput Component
function PoiInput({ id, globalX, rangeStart, onUpdate }) {
    const localVal = Math.max(0, globalX - rangeStart);
    const [val, setVal] = useState(localVal.toFixed(3));
    useEffect(() => {
        if (Math.abs(Number(val) - localVal) > 0.001) {
             setVal(localVal.toFixed(3));
        }
    }, [globalX, rangeStart]);
    const handleChange = (e) => {
        const v = e.target.value;
        setVal(v);
        const n = parseFloat(v);
        if (!isNaN(n)) {
            onUpdate(id, n + rangeStart);
        }
    };
    return (
        <input 
            type="number" 
            step="0.001" 
            className="w-16 p-1 border rounded bg-white font-mono text-blue-700 focus:ring-1 ring-blue-400"
            value={val} 
            onChange={handleChange} 
        />
    );
}

function ResultWindow({ onClose, children }) {
    const [container, setContainer] = useState(null);
    const newWindow = useRef(null);
    useEffect(() => {
        newWindow.current = window.open("", "_blank", "width=1000,height=800,left=200,top=100");
        const win = newWindow.current;
        if (!win) {
            alert("ポップアップがブロックされました。許可してください。");
            onClose();
            return;
        }
        Array.from(document.head.querySelectorAll('style, link[rel="stylesheet"], script')).forEach(node => {
            win.document.head.appendChild(node.cloneNode(true));
        });
        win.document.title = "構造計算結果 (リアルタイム表示)";
        win.document.body.className = "bg-slate-50 text-slate-800 p-4 overflow-y-auto";
        const div = win.document.createElement("div");
        div.id = "portal-root";
        win.document.body.appendChild(div);
        setContainer(div);
        win.onbeforeunload = () => {
            onClose();
        };
        return () => {
            if (win && !win.closed) {
                win.close();
            }
        };
    }, []);
    return container ? createPortal(children, container) : null;
}

function ResultContent({ results, sectionProps, loads, spans, supports, totalLength, finalPoiData, userPoi, setUserPoi }) {
    return (
        <div className="space-y-6 container mx-auto max-w-5xl">
            <header className="border-b pb-4 mb-4">
                <h1 className="text-2xl font-bold text-slate-800 flex items-center gap-2">
                    <Activity className="w-6 h-6 text-blue-600" />
                    計算結果モニター
                </h1>
                <p className="text-sm text-slate-500">メイン画面の入力変更がリアルタイムに反映されます</p>
            </header>
            <section>
                <h3 className="text-sm font-bold text-slate-600 mb-2 border-l-4 border-blue-500 pl-2">最大値・反力一覧</h3>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <ResultBox label="最大M (+)" val={results.bounds.maxM_pos} x={results.bounds.maxM_pos_x} unit="kN·m" color="text-emerald-600" sub={`σ=${results.bounds.maxSigma_pos.toFixed(0)}`} />
                    <ResultBox label="最大M (-)" val={results.bounds.maxM_neg} x={results.bounds.maxM_neg_x} unit="kN·m" color="text-red-600" sub={`σ=${Math.abs(results.bounds.maxSigma_neg).toFixed(0)}`} />
                    <ResultBox label="最大たわみ" val={results.bounds.maxDeflection} x={results.bounds.maxDef_x} unit="mm" color="text-blue-600" />
                    <ResultBox label="最大せん断" val={results.bounds.maxShear} x={results.bounds.maxShear_x} unit="kN" color="text-amber-600" />
                    {results.reactions.map((r, i) => (
                        <ResultBox key={i} label={`反力 ${r.label}`} val={r.val} unit="kN" color="text-purple-600" sub={`@${r.x.toFixed(1)}m`} />
                    ))}
                </div>
            </section>
            <section className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 overflow-hidden">
                <h3 className="text-sm font-bold text-slate-500 mb-4 flex items-center justify-between">
                    <span>応力図・変位図</span>
                    <span className="text-xs font-normal bg-slate-100 px-2 py-1 rounded text-slate-500">Auto Scale</span>
                </h3>
                <AdvancedVisualizer spans={spans} supports={supports} totalLength={totalLength} loads={loads} results={results} />
            </section>
            <section className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <PoiTable 
                    finalPoiData={finalPoiData} 
                    userPoi={userPoi} 
                    setUserPoi={setUserPoi} 
                    totalLength={totalLength} 
                    spans={spans} 
                    results={results}
                    sectionProps={sectionProps}
                />
            </section>
        </div>
    );
}
  
function App() {
  // --- External Data States (Empty by default) ---
  const [steelDB, setSteelDB] = useState({});
  const [concreteStrengths, setConcreteStrengths] = useState([]);
  const [historyData, setHistoryData] = useState([]);
  const [manualData, setManualData] = useState([]);
  const [dataLoaded, setDataLoaded] = useState(false);

  // --- Fetch Data on Mount ---
  useEffect(() => {
    async function loadData() {
        try {
            const response = await fetch('./data.json');
            if (response.ok) {
                const data = await response.json();
                if (data.steel_db) setSteelDB(data.steel_db);
                if (data.concrete_strengths) setConcreteStrengths(data.concrete_strengths);
                if (data.history) setHistoryData(data.history);
                if (data.manual) setManualData(data.manual);
                setDataLoaded(true);
            } else {
                console.warn('data.json not found. App running in empty data mode.');
                // データがなくてもアプリは動くが、リストは空になる
            }
        } catch (error) {
            console.error('Failed to load data.json', error);
        }
    }
    loadData();
  }, []);

  // --- Derived State for Steel Lists ---
  // データが空の場合でも、空配列として各カテゴリを定義しておく
  const STEEL_LISTS = useMemo(() => {
      const db = steelDB || {};
      const keys = Object.keys(db);
      // 安全なフィルタリング
      const filterKeys = (predicate) => keys.length > 0 ? keys.filter(predicate) : [];
      
      return {
        H: filterKeys(k => k.startsWith('H')),
        Channel: filterKeys(k => k.startsWith('C') && !k.includes('x1.6') && !k.includes('x2.3') && !k.includes('x3.2')),
        LipChannel: filterKeys(k => k.startsWith('C') && (k.includes('x1.6') || k.includes('x2.3') || k.includes('x3.2'))),
        Angle: filterKeys(k => k.startsWith('L') && !k.startsWith('LSP')),
        SheetPile: ['SP-II', 'SP-III', 'SP-IV', 'SP-VL', 'SP-VIL'].filter(k => db[k]), // DBに存在するかチェック
        SheetPileW: ['SP-IIw', 'SP-IIIw', 'SP-IVw'].filter(k => db[k]),
        SheetPileH: ['SP-10H', 'SP-25H'].filter(k => db[k]),
        LightSheetPile: ['LSP-1', 'LSP-2'].filter(k => db[k]),
        SquarePipe: filterKeys(k => k.startsWith('Square')),
      };
  }, [steelDB]);

  // --- States ---
  const [spanStr, setSpanStr] = useState(INITIAL_SPAN);
  const [beamType, setBeamType] = useState('simple');
  const [loads, setLoads] = useState([{ id: 1, type: 'point', mag: 10, pos: 3, length: 0 }]);
  const [showHelp, setShowHelp] = useState(false); // Help Modal State
  const [showHistory, setShowHistory] = useState(false); // Version History Modal State
  const [showResultWindow, setShowResultWindow] = useState(false);
    
  // matType: steel | concrete | manual
  const [matType, setMatType] = useState('steel');
  const [steelShape, setSteelShape] = useState('H');
  const [steelProfileIdx, setSteelProfileIdx] = useState(9); // Default index
  const [steelAxis, setSteelAxis] = useState('strong');
    
  // Manual Input States
  const [manualI, setManualI] = useState("1000"); // cm4
  const [manualZ, setManualZ] = useState("100");  // cm3
  const [manualA, setManualA] = useState("30.0"); // cm2
  const [manualE, setManualE] = useState("205"); // kN/mm2 (205000 N/mm2)
    
  const [effI, setEffI] = useState("1.0"); 
  const [effZ, setEffZ] = useState("1.0");
  const [wallLength, setWallLength] = useState("1.0"); // 施工延長(m)

  const [rcFcIdx, setRcFcIdx] = useState(1);
  const [rcWidthStr, setRcWidthStr] = useState('300');
  const [rcDepthStr, setRcDepthStr] = useState('600');

  const [userPoi, setUserPoi] = useState([]); 

  const [newLoadType, setNewLoadType] = useState('point');
  const [newMagStart, setNewMagStart] = useState(10);
  const [newMagEnd, setNewMagEnd] = useState(10);
  const [newPos, setNewPos] = useState(0);
  const [newLength, setNewLength] = useState(2);

  const [calcError, setCalcError] = useState(null);

  const fileInputRef = useRef(null);

  // --- 解析モデルの計算 ---
  const { spans, totalLength, supports } = useMemo(() => {
    const vals = normalizeText(spanStr).replace(/,/g, ' ').split(/\s+/).map(Number).filter(n => !isNaN(n) && n > 0);
    const safeVals = vals.length > 0 ? vals : [6.0];
    let s = safeVals;
    let supp = [];

    switch (beamType) {
      case 'simple': s = [safeVals[0]]; supp = ['pin', 'roller']; break;
      case 'fixed': s = [safeVals[0]]; supp = ['fixed', 'fixed']; break;
      case 'cantilever': s = [safeVals[0]]; supp = ['fixed', 'free']; break;
      case 'overhang_one': 
        if(s.length < 2) s = [s[0], s[0]*0.3]; 
        s = s.slice(0, 2); supp = ['pin', 'roller', 'free']; break;
      case 'overhang_both': 
        if(s.length < 3) { const main = s.length>=2?s[1]:s[0]; const sub = s.length>=1?s[0]:2.0; s = [sub, main, sub]; }
        s = s.slice(0, 3); supp = ['free', 'pin', 'roller', 'free']; break;
      case 'continuous2': 
        if(s.length < 2) s = [s[0], s[0]];
        s = s.slice(0, 2); supp = ['pin', 'roller', 'roller']; break;
      case 'continuous2_overhang': 
        if(s.length < 3) s = [s[0], s[0], s[0]*0.3];
        s = s.slice(0, 3); supp = ['pin', 'roller', 'roller', 'free']; break;
      case 'continuous3': 
        if(s.length < 3) s = [s[0], s[0], s[0]];
        s = s.slice(0, 3); supp = ['pin', 'roller', 'roller', 'roller']; break;
      default: s = [6.0]; supp = ['pin', 'roller'];
    }
    return { spans: s, totalLength: s.reduce((a,b)=>a+b, 0), supports: supp };
  }, [spanStr, beamType]);

  // --- 断面性能の取得 ---
  const sectionProps = useMemo(() => {
    let E = 0, I = 0, Z = 0, label = '', dims = {}, A = 0, w = 0;
    
    // Manual Mode Logic
    if (matType === 'manual') {
        const iVal = parseFloat(manualI);
        const zVal = parseFloat(manualZ);
        const aVal = parseFloat(manualA);
        const eVal = parseFloat(manualE);

        I = (isNaN(iVal) ? 0 : iVal) * 10000; // cm4 -> mm4
        Z = (isNaN(zVal) ? 0 : zVal) * 1000;  // cm3 -> mm3
        A = (isNaN(aVal) ? 0 : aVal);         // cm2
        E = (isNaN(eVal) ? 0 : eVal) * 1000;  // kN/mm2 -> N/mm2

        w = A * 0.785; 
        label = `任意断面 (I=${manualI}, Z=${manualZ})`;
        dims = { type: 'manual' }; 
    
    } else if (matType === 'steel') {
      E = E_STEEL; 
      const list = STEEL_LISTS[steelShape] || [];
      // リストが空、またはインデックス外の場合は安全に処理
      const name = list.length > 0 && list[steelProfileIdx] ? list[steelProfileIdx] : (list.length > 0 ? list[0] : '');
      
      // Pass current DB state to helper
      const props = getSteelProps(steelShape, name, steelAxis, steelDB);
      dims = props;

      if (steelShape.includes('SheetPile')) {
          const wVal = parseFloat(wallLength);
          const safeWL = (isNaN(wVal) || wVal <= 0) ? 1.0 : wVal;
          const iVal = parseFloat(effI);
          const safeEffI = (isNaN(iVal) || iVal < 0) ? 1.0 : iVal;
          const zVal = parseFloat(effZ);
          const safeEffZ = (isNaN(zVal) || zVal < 0) ? 1.0 : zVal;

          I = props.I * safeEffI * safeWL;
          Z = props.Z * safeEffZ * safeWL;
          A = props.A * safeWL;
          w = props.w * safeWL;
          label = `${name || 'No Data'} (L=${safeWL}m)`;
      } else {
          I = props.I; 
          Z = props.Z;
          A = props.A;
          w = props.w;
          label = `${name || 'No Data'} (${steelAxis === 'strong' ? '強軸' : '弱軸'})`;
      }

    } else {
      // コンクリート強度DBが空の場合のガード
      const safeStrengths = concreteStrengths.length > 0 ? concreteStrengths : [{ label: 'Unk', Fc: 0, Ec: 20000 }];
      const fcData = safeStrengths[rcFcIdx] || safeStrengths[0];
      
      const b = parseFloat(rcWidthStr) || 0;
      const D = parseFloat(rcDepthStr) || 0;
      E = fcData.Ec; I = (b * Math.pow(D, 3)) / 12; Z = (b * Math.pow(D, 2)) / 6; 
      dims = { H: D, B: b, type: 'RC' };
      const areaM2 = (b/1000)*(D/1000);
      A = areaM2 * 10000; // cm2
      w = areaM2 * 2400; // kg/m
      label = `RC造 ${fcData.label} ${b}x${D}`;
    }
    return { E, I, Z, label, dims, shape: steelShape, axis: steelAxis, matType, effI, effZ, wallLength, A, w };
  }, [matType, steelShape, steelProfileIdx, steelAxis, rcFcIdx, rcWidthStr, rcDepthStr, effI, effZ, wallLength, manualI, manualZ, manualA, manualE, steelDB, concreteStrengths, STEEL_LISTS]);

  // --- 構造解析実行 ---
  const results = useMemo(() => {
    try {
      setCalcError(null);
      return solveGeneralBeam(spans, supports, loads, RESOLUTION, sectionProps);
    } catch (e) {
      console.error(e);
      setCalcError("解析エンジンでエラーが発生しました。入力を確認してください。");
      return generateEmptyResult();
    }
  }, [spans, supports, loads, sectionProps]);

  // ... (Auto Poi, Final Poi, Export/Import Logic remains the same) ...
  // --- 自動着目点(POI)の算出 ---
  const autoPoiPoints = useMemo(() => {
    if(!results.bounds) return [];
    const R = (v) => Math.round(v * 1000) / 1000;
    const points = new Set();
    points.add(R(0));
    points.add(R(totalLength));
    let cx = 0;
    spans.forEach(s => { cx += s; points.add(R(cx)); });
    loads.forEach(l => {
        points.add(R(l.pos));
        if (l.type === 'moment') {
            points.add(R(Math.max(0, l.pos - 1e-6)));
            points.add(R(Math.min(totalLength, l.pos + 1e-6)));
        } else if(l.type !== 'point') {
            points.add(R(l.pos + l.length));
        }
    });
    if (results.bounds) {
        const b = results.bounds;
        [b.maxShear_x, b.maxM_pos_x, b.maxM_neg_x, b.maxDef_x].forEach(x => { if (x !== undefined) points.add(R(x)); });
    }
    if (results.spanBounds) {
        results.spanBounds.forEach(sb => {
            [sb.maxM_x, sb.minM_x, sb.maxQ_x, sb.minQ_x, sb.maxD_x, sb.minD_x].forEach(x => { if (x !== undefined) points.add(R(x)); });
        });
    }
    const findZeroCrossings = (data) => {
        const crossings = [];
        if (!data) return crossings;
        for (let i = 1; i < data.length - 1; i++) {
            if (data[i].y * data[i+1].y < -1e-6) {
                const x = data[i].x + (0 - data[i].y) * (data[i+1].x - data[i].x) / (data[i+1].y - data[i].y);
                crossings.push(x);
            } 
            else if (Math.abs(data[i].y) < 1e-6) {
                const prevY = data[i-1].y;
                const nextY = data[i+1].y;
                if (Math.abs(prevY) > 1e-4 || Math.abs(nextY) > 1e-4) crossings.push(data[i].x);
            }
        }
        return crossings;
    };
    findZeroCrossings(results.momentData).forEach(x => points.add(R(x)));
    findZeroCrossings(results.shearData).forEach(x => points.add(R(x)));
    return Array.from(points).filter(p => p >= 0 && p <= totalLength).sort((a, b) => a - b);
  }, [totalLength, spans.join(','), loads, results.bounds]);

  const finalPoiData = useMemo(() => {
      const merged = [];
      autoPoiPoints.forEach(x => merged.push({ type: 'auto', x, id: `auto-${x}` }));
      userPoi.forEach(p => merged.push({ type: 'user', x: p.x, id: p.id }));
      return merged.sort((a,b) => a.x - b.x).map(p => {
          return { ...p, res: getResultAt(p.x, results, sectionProps) };
      });
  }, [autoPoiPoints, userPoi, results, sectionProps]);

  const exportToCSV = () => {
    let csvContent = "\uFEFF";
    csvContent += `[INFO],Version,21.29,Date,${new Date().toLocaleDateString()}\n`;
    csvContent += `[INPUT_BASIC],SpanStr,"${spanStr}",BeamType,${beamType},MatType,${matType}\n`;
    if (matType === 'steel') {
        csvContent += `[INPUT_STEEL],Shape,${steelShape},ProfileIdx,${steelProfileIdx},Axis,${steelAxis}\n`;
        if (steelShape.includes('SheetPile')) {
            csvContent += `[INPUT_PILE],EffI,${effI},EffZ,${effZ},WallLength,${wallLength}\n`;
        }
    } else if (matType === 'manual') {
        csvContent += `[INPUT_MANUAL],I,${manualI},Z,${manualZ},A,${manualA},E,${manualE}\n`;
    } else if (matType === 'concrete') {
        csvContent += `[INPUT_RC],FcIdx,${rcFcIdx},Width,${rcWidthStr},Depth,${rcDepthStr}\n`;
    }
    csvContent += `[HEADER_LOAD],Id,Type,Mag,Pos,Length,MagEnd\n`;
    loads.forEach(l => { csvContent += `[LOAD],${l.id},${l.type},${l.mag},${l.pos},${l.length},${l.magEnd || 0}\n`; });
    csvContent += `[HEADER_POI],Id,x\n`;
    userPoi.forEach(p => { csvContent += `[USER_POI],${p.id},${p.x}\n`; });
    csvContent += `[HEADER_RESULT],Section,Item,Value,Unit,LocationX\n`;
    csvContent += `[SECTION_PROPS],Label,"${sectionProps.label}",I(mm4),${sectionProps.I},Z(mm3),${sectionProps.Z},E(N/mm2),${sectionProps.E},A(cm2),${sectionProps.A},w(kg/m),${sectionProps.w}\n`;
    results.reactions.forEach(r => { csvContent += `[RESULT_REACTION],${r.label},${r.val.toFixed(2)},kN,${r.x.toFixed(3)}\n`; });
    if (results.spanBounds) {
        csvContent += `[HEADER_SPAN_BOUNDS],SpanIdx,Length,Item,Value,Unit,LocalX,GlobalX\n`;
        results.spanBounds.forEach(sb => {
            const offset = spans.slice(0, sb.spanIndex).reduce((a, b) => a + b, 0);
            const idx = sb.spanIndex + 1; const len = spans[sb.spanIndex];
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxM_Pos,${sb.maxM},kN.m,${(sb.maxM_x - offset).toFixed(3)},${sb.maxM_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxM_Neg,${sb.minM},kN.m,${(sb.minM_x - offset).toFixed(3)},${sb.minM_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxQ_Pos,${sb.maxQ},kN,${(sb.maxQ_x - offset).toFixed(3)},${sb.maxQ_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxQ_Neg,${sb.minQ},kN,${(sb.minQ_x - offset).toFixed(3)},${sb.minQ_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxD_Pos,${sb.maxD},mm,${(sb.maxD_x - offset).toFixed(3)},${sb.maxD_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxD_Neg,${sb.minD},mm,${(sb.minD_x - offset).toFixed(3)},${sb.minD_x}\n`;
        });
    }
    csvContent += `[HEADER_SPAN_DETAIL],SpanIdx,Type,LocalX(m),GlobalX(m),Q(kN),M(kN.m),Sigma(N/mm2),Deflection(mm)\n`;
    let currentX = 0;
    spans.forEach((len, sIdx) => {
        const rangeStart = currentX; const rangeEnd = currentX + len;
        const spanPoints = finalPoiData.filter(p => p.x >= rangeStart - 1e-4 && p.x <= rangeEnd + 1e-4);
        spanPoints.forEach(p => {
            const localX = Math.max(0, Math.min(len, p.x - rangeStart));
            const r = getResultAt(p.x, results, sectionProps, sIdx);
            csvContent += `[SPAN_DETAIL],${sIdx+1},${p.type},${localX.toFixed(3)},${p.x.toFixed(3)},${(r.Q||0).toFixed(3)},${(r.M||0).toFixed(3)},${(r.sigma||0).toFixed(2)},${(r.deflection||0).toFixed(3)}\n`;
        });
        currentX += len;
    });
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `structural_calc_result_${new Date().toISOString().slice(0,10)}.csv`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const importFromCSV = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    const parseCSVLine = (text) => {
        const result = []; let curr = ''; let inQuote = false;
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            if (char === '"') inQuote = !inQuote;
            else if (char === ',' && !inQuote) { result.push(curr); curr = ''; } else curr += char;
        }
        result.push(curr);
        return result.map(s => s.trim().replace(/^"|"$/g, ''));
    };
    reader.onload = (e) => {
        try {
            const text = e.target.result;
            const lines = text.split(/\r\n|\n/);
            const newLoads = []; const newUserPoi = []; let hasInput = false;
            lines.forEach(line => {
                if (!line.trim()) return;
                const cols = parseCSVLine(line);
                if(cols.length < 2) return;
                const tag = cols[0];
                if(tag === '[INPUT_BASIC]') {
                    hasInput = true; setSpanStr(cols[2]); setBeamType(cols[4]); setMatType(cols[6]);
                } else if (tag === '[INPUT_STEEL]') {
                    setSteelShape(cols[2]); setSteelProfileIdx(Number(cols[4])); setSteelAxis(cols[6]);
                } else if (tag === '[INPUT_MANUAL]') {
                    setManualI(cols[2]); setManualZ(cols[4]); setManualA(cols[6]); setManualE(cols[8]);
                } else if (tag === '[INPUT_RC]') {
                    setRcFcIdx(Number(cols[2])); setRcWidthStr(cols[4]); setRcDepthStr(cols[6]);
                } else if (tag === '[INPUT_PILE]') {
                    setEffI(cols[2]); setEffZ(cols[4]); setWallLength(cols[6]);
                } else if (tag === '[LOAD]') {
                    newLoads.push({ id: Number(cols[1]), type: cols[2], mag: Number(cols[3]), pos: Number(cols[4]), length: Number(cols[5]), magEnd: Number(cols[6]) });
                } else if (tag === '[USER_POI]') {
                    newUserPoi.push({ id: Number(cols[1]), x: Number(cols[2]) });
                }
            });
            if (hasInput) { setLoads(newLoads); setUserPoi(newUserPoi); setCalcError(null); } else { setCalcError("有効な入力データが見つかりませんでした。"); }
        } catch (err) { console.error(err); setCalcError("ファイルの解析に失敗しました。正しいCSV形式ではありません。"); }
    };
    reader.readAsText(file);
    event.target.value = '';
  };

  const addLoad = () => {
    const id = Date.now();
    let safePos = Math.max(0, Math.min(totalLength, Number(newPos)));
    let safeLength = Math.max(0, Number(newLength));
    if ((newLoadType === 'distributed' || newLoadType === 'trapezoid') && safePos + safeLength > totalLength) {
      safeLength = totalLength - safePos;
    }
    setLoads([...loads, {
      id, type: newLoadType, mag: Number(newMagStart), pos: safePos, length: safeLength,
      magEnd: newLoadType === 'trapezoid' ? Number(newMagEnd) : (newLoadType === 'distributed' ? Number(newMagStart) : 0)
    }]);
  };

  const handleTypeChange = (newType) => {
    setBeamType(newType);
    if(newType.includes('continuous3') && spanStr.indexOf(',')===-1) setSpanStr("5.0, 5.0, 5.0");
    else if(newType.includes('continuous2') && spanStr.indexOf(',')===-1) setSpanStr("5.0, 5.0");
    else if(newType.includes('overhang_one') && spanStr.indexOf(',')===-1) setSpanStr("6.0, 2.0");
    else if(newType.includes('overhang_both') && spanStr.indexOf(',')===-1) setSpanStr("2.0, 6.0, 2.0");
  };

  const handlePrint = () => {
      const reportHtml = renderToStaticMarkup(
          <PrintReport 
              params={{ 
                  spanStr, beamType, loads, matType, 
                  sectionProps, results, finalPoiData, 
                  spans, totalLength, supports 
              }} 
          />
      );
      const printWindow = window.open('', '_blank');
      if (!printWindow) { alert("ポップアップがブロックされました。ブラウザの設定で許可してください。"); return; }
      const htmlContent = `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>構造計算書 - 印刷プレビュー</title><script src="https://cdn.tailwindcss.com"><\/script><style>body { font-family: 'Helvetica Neue', Arial, sans-serif; -webkit-print-color-adjust: exact; print-color-adjust: exact; } @page { size: A4 portrait; margin: 10mm; } @media print { .no-print { display: none; } h2 { break-before: auto; } .page-break { break-before: page; } .avoid-break { page-break-inside: avoid; } } .container { max-width: 190mm; margin: 0 auto; background: white; padding: 5mm; box-shadow: 0 0 10px rgba(0,0,0,0.1); } @media screen { body { background: #f1f5f9; padding: 20px; } }</style></head><body><div class="container">${reportHtml}</div><script>window.onload = () => { setTimeout(() => { window.print(); }, 800); };<\/script></body></html>`;
      printWindow.document.write(htmlContent);
      printWindow.document.close();
  };

  return (
    <div className="min-h-screen bg-slate-50 font-sans text-slate-800">
      <div className="no-print p-4 md:p-8">
        <div className="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6">
            {/* Header */}
            <div className="lg:col-span-12 flex flex-col md:flex-row md:items-center justify-between gap-4">
            <div>
                <h1 className="text-3xl font-bold text-slate-900 flex items-center gap-3">
                <Activity className="w-8 h-8 text-blue-600" />
                構造計算アプリ Pro <span className="text-sm font-normal text-slate-500 bg-slate-200 px-2 py-1 rounded">v21.30</span>
                </h1>
                <p className="text-slate-500 text-sm mt-1">任意断面入力・モーメント荷重対応・不連続点自動補正</p>
            </div>
            
            <div className="flex items-center gap-2">
                <button onClick={() => setShowHistory(true)} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><History className="w-4 h-4 text-blue-500" />履歴</button>
                <button onClick={() => setShowHelp(true)} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><HelpCircle className="w-4 h-4 text-blue-500" />ヘルプ</button>
                <button onClick={() => setShowResultWindow(!showResultWindow)} className={`flex items-center gap-2 px-3 py-2 border border-slate-300 rounded-lg text-sm font-bold shadow-sm transition-all ${showResultWindow ? 'bg-blue-100 text-blue-700 border-blue-400' : 'bg-white text-slate-600 hover:bg-slate-50'}`}>
                <ExternalLink className="w-4 h-4" />別窓結果
                </button>
                <button onClick={handlePrint} className="flex items-center gap-2 px-3 py-2 bg-blue-600 border border-transparent rounded-lg text-sm font-bold text-white hover:bg-blue-700 shadow-sm transition-all"><Printer className="w-4 h-4" />印刷</button>
                
                <button onClick={exportToCSV} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><FileDown className="w-4 h-4" />結果出力(CSV)</button>
                <button onClick={() => fileInputRef.current?.click()} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><Upload className="w-4 h-4" />読込(CSV)</button>
                <input type="file" ref={fileInputRef} accept=".csv" onChange={importFromCSV} className="hidden" />
            </div>
            </div>

            {/* Help Modal Render */}
            {showHelp && <HelpModal onClose={() => setShowHelp(false)} manualData={manualData} />}
            {/* Version History Modal Render */}
            {showHistory && <VersionHistoryModal onClose={() => setShowHistory(false)} historyData={historyData} />}

            {/* Sidebar */}
            <div className="lg:col-span-4 space-y-6">
           
            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2"><Settings className="w-5 h-5 text-slate-400" />モデル・荷重</h2>
                <div className="space-y-4 mb-6">
                <div>
                    <label className="text-xs font-bold text-slate-500 block mb-1">梁タイプ</label>
                    <select value={beamType} onChange={(e) => handleTypeChange(e.target.value)} className="w-full p-2 border border-slate-300 rounded text-sm">
                    {Object.entries(BEAM_TYPES).map(([key, val]) => <option key={key} value={key}>{val.label}</option>)}
                    </select>
                </div>
                <div>
                    <label className="text-xs font-bold text-slate-500 block mb-1">スパン長さ (m)</label>
                    <input type="text" value={spanStr} onChange={e=>setSpanStr(e.target.value)} className="w-full p-2 border rounded text-sm" placeholder="例: 6.0"/>
                    <p className="text-[10px] text-slate-400 mt-1">{BEAM_TYPES[beamType]?.hint || 'カンマ区切りで複数入力可'}</p>
                </div>
                </div>
                <div className="border-t pt-4">
                <h3 className="text-sm font-bold text-slate-600 mb-3">荷重追加</h3>
                <div className="flex bg-slate-100 p-1 rounded mb-4">{['point', 'distributed', 'trapezoid', 'moment'].map(type => (<button key={type} onClick={() => setNewLoadType(type)} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${newLoadType === type ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>{type === 'point' ? '集中' : type === 'distributed' ? '等分布' : type === 'trapezoid' ? '台形' : 'モーメント'}</button>))}</div>
                <div className="space-y-3 mb-4">
                    <div className="flex gap-2">
                    <div className="w-1/2"><label className="text-xs text-slate-500 block">荷重{newLoadType!=='point' && newLoadType!=='moment' && '(始)'}</label><input type="number" value={newMagStart} onChange={e=>setNewMagStart(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    {newLoadType==='trapezoid' && <div className="w-1/2"><label className="text-xs text-slate-500 block">荷重(終)</label><input type="number" value={newMagEnd} onChange={e=>setNewMagEnd(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>}
                    </div>
                    <div className="flex gap-2">
                    <div className="w-1/2"><label className="text-xs text-slate-500 block">位置 x</label><input type="number" value={newPos} onChange={e=>setNewPos(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    {newLoadType!=='point' && newLoadType!=='moment' && <div className="w-1/2"><label className="text-xs text-slate-500 block">長さ L</label><input type="number" value={newLength} onChange={e=>setNewLength(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>}
                    </div>
                    {newLoadType === 'moment' && <p className="text-[10px] text-slate-400">※時計回りを正(+)として入力</p>}
                </div>
                <button onClick={addLoad} className="w-full py-2 bg-blue-600 text-white rounded text-sm font-bold hover:bg-blue-700 flex items-center justify-center gap-2"><Plus className="w-4 h-4"/> 荷重を追加</button>
                </div>
                <div className="mt-4 space-y-1 max-h-[150px] overflow-y-auto text-sm">
                {loads.map(l => (
                    <div key={l.id} className="flex justify-between items-center p-2 bg-slate-50 border rounded">
                    <div className="flex flex-col"><span className="font-bold text-slate-700">{l.type==='point' ? `P=${l.mag}kN` : l.type==='moment' ? `M=${l.mag}kN·m` : `w=${l.mag}kN/m`}</span><span className="text-xs text-slate-500">x={l.pos}m {l.type!=='point' && l.type!=='moment' && `(L=${l.length})`}</span></div>
                    <button onClick={()=>setLoads(loads.filter(x=>x.id!==l.id))}><Trash2 className="w-4 h-4 text-slate-300 hover:text-red-500"/></button>
                    </div>
                ))}
                </div>
            </div>

 <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2"><Layers className="w-5 h-5 text-slate-400" />断面・材料設定</h2>
                
                <div className="flex bg-slate-100 p-1 rounded-lg mb-4">
                    <button onClick={() => setMatType('steel')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'steel' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>S造</button>
                    <button onClick={() => setMatType('concrete')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'concrete' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>RC造</button>
                    <button onClick={() => setMatType('manual')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'manual' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>任意</button>
                </div>

                {matType === 'steel' && (
                <div className="space-y-4">
                      <div>
                        <label className="text-xs text-slate-500 font-bold block mb-1">鋼材種別</label>
                        <select value={steelShape} onChange={e => { setSteelShape(e.target.value); setSteelProfileIdx(0); }} className="w-full p-2 border rounded text-sm">
                            <option value="H">H形鋼</option>
                            <option value="Channel">溝形鋼</option>
                            <option value="LipChannel">C形鋼</option>
                            <option value="Angle">山形鋼</option>
                            <option value="SheetPile">鋼矢板 (U形)</option>
                            <option value="SheetPileW">鋼矢板 (広幅/w)</option>
                            <option value="SheetPileH">鋼矢板 (ハット形)</option>
                            <option value="LightSheetPile">軽量鋼矢板</option>
                            <option value="SquarePipe">角形鋼管 (Square Pipe)</option>
                        </select>
                    </div>
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">断面サイズ</label>
                    <select value={steelProfileIdx} onChange={e => setSteelProfileIdx(Number(e.target.value))} className="w-full p-2 border rounded text-sm font-mono">
                        {STEEL_LISTS[steelShape] && STEEL_LISTS[steelShape].map((name, idx) => <option key={idx} value={idx}>{name}</option>)}
                    </select>
                    </div>
                    {(!steelShape.includes('SheetPile') && !steelShape.includes('SquarePipe')) && (
                        <div className="flex bg-slate-50 border rounded p-1"><button onClick={() => setSteelAxis('strong')} className={`flex-1 text-xs py-1 rounded font-bold ${steelAxis === 'strong' ? 'bg-blue-100 text-blue-700' : 'text-slate-400'}`}>強軸 (X)</button><button onClick={() => setSteelAxis('weak')} className={`flex-1 text-xs py-1 rounded font-bold ${steelAxis === 'weak' ? 'bg-blue-100 text-blue-700' : 'text-slate-400'}`}>弱軸 (Y)</button></div>
                    )}
                    
                    {(steelShape.includes('SheetPile')) && (
                    <div className="mt-2 space-y-2 p-3 bg-yellow-50 rounded border border-yellow-200">
                        <div>
                            <label className="text-[10px] text-slate-500 font-bold block">施工延長 L (m) <span className="font-normal text-slate-400">(計算用壁幅)</span></label>
                            <input type="number" step="0.1" value={wallLength} onChange={e=>setWallLength(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right font-bold text-blue-600"/>
                        </div>
                        <div className="grid grid-cols-2 gap-3 pt-1 border-t border-yellow-200/50">
                            <div>
                                <label className="text-[10px] text-slate-500 font-bold block">効率 (I用)</label>
                                <input type="number" step="0.05" value={effI} onChange={e=>setEffI(e.target.value)} className="w-full p-1 border rounded text-xs bg-white text-right"/>
                            </div>
                            <div>
                                <label className="text-[10px] text-slate-500 font-bold block">効率 (Z用)</label>
                                <input type="number" step="0.05" value={effZ} onChange={e=>setEffZ(e.target.value)} className="w-full p-1 border rounded text-xs bg-white text-right"/>
                            </div>
                        </div>
                    </div>
                    )}
                </div>
                )}
                
                {matType === 'concrete' && (
                <div className="space-y-4">
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">コンクリート</label><select value={rcFcIdx} onChange={e => setRcFcIdx(Number(e.target.value))} className="w-full p-2 border rounded text-sm">
                        {concreteStrengths.length > 0 ? (
                            concreteStrengths.map((fc, idx) => <option key={idx} value={idx}>{fc.label}</option>)
                        ) : (
                            <option value="0">Loading...</option>
                        )}
                    </select></div>
                    <div className="grid grid-cols-2 gap-3">
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">幅 b</label><input type="number" value={rcWidthStr} onChange={e=>setRcWidthStr(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">高さ D</label><input type="number" value={rcDepthStr} onChange={e=>setRcDepthStr(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    </div>
                </div>
                )}

                {matType === 'manual' && (
                <div className="space-y-3 bg-blue-50 p-4 rounded border border-blue-100">
                      <p className="text-xs text-slate-500 mb-2 font-bold text-center border-b border-blue-200 pb-2">任意断面入力</p>
                      <div>
                        <label className="text-[10px] text-slate-500 font-bold block">断面二次モーメント Ix (cm⁴)</label>
                        <input type="number" step="1" value={manualI} onChange={e=>setManualI(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                    <div>
                        <label className="text-[10px] text-slate-500 font-bold block">断面係数 Zx (cm³)</label>
                        <input type="number" step="1" value={manualZ} onChange={e=>setManualZ(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                      <div>
                        <label className="text-[10px] text-slate-500 font-bold block">ヤング係数 E (kN/mm²)</label>
                        <input type="number" step="1" value={manualE} onChange={e=>setManualE(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                      <div>
                        <label className="text-[10px] text-slate-500 font-bold block">断面積 A (cm²) <span className="font-normal text-slate-400">(重量計算用)</span></label>
                        <input type="number" step="0.1" value={manualA} onChange={e=>setManualA(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                </div>
                )}

                <div className="mt-4 grid grid-cols-2 gap-4">
                <div className="p-3 bg-slate-50 rounded border text-xs space-y-1 font-mono text-slate-600">
                    <div className="flex justify-between"><span>Ix:</span> <span>{(sectionProps.I/10000).toFixed(3)} cm⁴</span></div>
                    <div className="flex justify-between"><span>Zx:</span> <span>{(sectionProps.Z/1000).toFixed(3)} cm³</span></div>
                    <div className="flex justify-between"><span>E :</span> <span>{(sectionProps.E/1000).toFixed(1)} kN/mm²</span></div>
                    <div className="flex justify-between text-slate-500 mt-1 border-t pt-1"><span>A :</span> <span>{sectionProps.A.toFixed(2)} cm²</span></div>
                    <div className="flex justify-between text-slate-500"><span>w :</span> <span>{sectionProps.w.toFixed(1)} kg/m</span></div>
                </div>
                <div className="flex items-center justify-center bg-white border rounded aspect-square p-2"><SectionProfileView props={sectionProps} /></div>
                </div>
            </div>

            </div>

            {/* Main Content */}
            <div className="lg:col-span-8 space-y-6">
            <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                <ResultBox label="最大M (+)" val={results.bounds.maxM_pos} x={results.bounds.maxM_pos_x} unit="kN·m" color="text-emerald-600" sub={`σ=${results.bounds.maxSigma_pos.toFixed(0)}`} />
                <ResultBox label="最大M (-)" val={results.bounds.maxM_neg} x={results.bounds.maxM_neg_x} unit="kN·m" color="text-red-600" sub={`σ=${Math.abs(results.bounds.maxSigma_neg).toFixed(0)}`} />
                <ResultBox label="最大たわみ" val={results.bounds.maxDeflection} x={results.bounds.maxDef_x} unit="mm" color="text-blue-600" />
                <ResultBox label="最大せん断" val={results.bounds.maxShear} x={results.bounds.maxShear_x} unit="kN" color="text-amber-600" />
                {results.reactions.map((r, i) => (
                <ResultBox key={i} label={`反力 ${r.label}`} val={r.val} unit="kN" color="text-purple-600" sub={`@${r.x.toFixed(1)}m`} />
                ))}
            </div>
            
            {calcError ? (
                <div className="bg-red-50 border-red-200 border p-4 text-red-700 rounded flex items-center gap-2"><AlertTriangle className="w-5 h-5"/>{calcError}</div>
            ) : (
                <>
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 overflow-hidden">
                    <h2 className="text-sm font-bold text-slate-500 mb-4 flex items-center justify-between">
                    <span>解析結果グラフ ({sectionProps.label})</span>
                    <span className="text-xs font-normal bg-slate-100 px-2 py-1 rounded text-slate-500">モデル全長: {totalLength.toFixed(2)}m</span>
                    </h2>
                    <AdvancedVisualizer spans={spans} supports={supports} totalLength={totalLength} loads={loads} results={results} />
                </div>
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                    <PoiTable 
                        finalPoiData={finalPoiData} 
                        userPoi={userPoi} 
                        setUserPoi={setUserPoi} 
                        totalLength={totalLength} 
                        spans={spans} 
                        results={results}
                        sectionProps={sectionProps}
                    />
                </div>
                </>
            )}
            </div>
        </div>
      </div> 

　　　　{showResultWindow && (
        <ResultWindow onClose={() => setShowResultWindow(false)}>
            <ResultContent 
                results={results}
                sectionProps={sectionProps}
                loads={loads}
                spans={spans}
                supports={supports}
                totalLength={totalLength}
                finalPoiData={finalPoiData}
                userPoi={userPoi}
                setUserPoi={setUserPoi}
            />
        </ResultWindow>
      )}
      
    </div>
  );
}

// ... (PrintReport, solveGeneralBeam, getResultAt, and other helper functions) ...
// ※これ以降のロジック関数群（solveGeneralBeamなど）は変更ないため、
//   元のコードのまま記述してください。ここでは省略せず全てのロジックを含めます。

function PrintReport({ params }) {
    const { sectionProps, results, loads, spans, totalLength, beamType, finalPoiData } = params;
    const today = new Date().toLocaleDateString('ja-JP');

    const spanRanges = spans.map((len, idx) => {
        const start = spans.slice(0, idx).reduce((a, b) => a + b, 0);
        return { idx, len, start, end: start + len };
    });

    return (
        <div className="space-y-6 text-sm text-slate-800">
            <header className="border-b-2 border-slate-800 pb-2 mb-4 flex justify-between items-end">
                <div>
                    <h1 className="text-xl font-bold text-slate-900">構造計算書</h1>
                    <p className="text-xs text-slate-500">Structural Analysis Report</p>
                </div>
                <div className="text-right">
                    <p className="font-bold text-sm">作成日: {today}</p>
                    <p className="text-xs text-slate-500">Ver 21.29</p>
                </div>
            </header>
            <div className="grid grid-cols-2 gap-6 mb-4 avoid-break">
                <section>
                    <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">1. 設計条件</h2>
                    <table className="w-full text-left text-xs border-collapse">
                        <tbody>
                            <tr className="border-b"><th className="py-1 text-slate-500 w-24">梁タイプ</th><td className="font-bold">{BEAM_TYPES[beamType]?.label}</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">スパン構成</th><td className="font-mono">{spans.map(s=>s.toFixed(2)+'m').join(' + ')} (L={totalLength.toFixed(2)}m)</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">使用材料</th><td className="font-bold">{sectionProps.label}</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">断面性能</th><td className="font-mono">
                                I={(sectionProps.I/10000).toFixed(3)}cm⁴, Z={(sectionProps.Z/1000).toFixed(3)}cm³, E={(sectionProps.E/1000).toFixed(1)}kN/mm²
                            </td></tr>
                        </tbody>
                    </table>
                </section>
                <section>
                    <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">2. 荷重条件</h2>
                    <table className="w-full text-xs text-left border border-slate-200">
                        <thead className="bg-slate-100">
                            <tr><th className="p-1 border">No.</th><th className="p-1 border">種類</th><th className="p-1 border">大きさ</th><th className="p-1 border">位置</th></tr>
                        </thead>
                        <tbody>
                            {loads.map((l, i) => (
                                <tr key={l.id} className="border-b">
                                    <td className="p-1 border text-center">{i+1}</td>
                                    <td className="p-1 border">{l.type === 'point' ? '集中' : l.type === 'moment' ? 'モーメント' : '分布'}</td>
                                    <td className="p-1 border font-mono">{l.type==='trapezoid'?`${l.mag}~${l.magEnd}`:l.mag}</td>
                                    <td className="p-1 border font-mono">{l.type==='point'||l.type==='moment'?l.pos:`${l.pos}~${l.pos+l.length}`}</td>
                                </tr>
                            ))}
                            {loads.length===0 && <tr><td colSpan="4" className="p-2 text-center text-slate-400">なし</td></tr>}
                        </tbody>
                    </table>
                </section>
            </div>
            <section className="mb-4">
                <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">3. 解析結果一覧（スパン別最大・最小）</h2>
                <div className="grid grid-cols-1 gap-4">
                    {results.spanBounds.map((sb, idx) => {
                        const offset = spans.slice(0, idx).reduce((a, b) => a + b, 0);
                        return (
                            <div key={idx} className="avoid-break border rounded-lg overflow-hidden mb-2">
                                <div className="text-xs font-bold bg-slate-100 px-2 py-1 border-b text-slate-700">
                                    径間 {idx + 1} <span className="font-normal ml-2 text-slate-500">L = {spans[idx].toFixed(2)}m</span>
                                </div>
                                <table className="w-full text-xs text-right">
                                    <thead className="bg-slate-50 text-slate-600">
                                            <tr>
                                                <th className="p-1 border-b w-32 text-left pl-2">項目</th>
                                                <th className="p-1 border-b">値</th>
                                                <th className="p-1 border-b">位置 x (local)</th>
                                                <th className="p-1 border-b">応力度 σ (N/mm²)</th>
                                            </tr>
                                    </thead>
                                    <tbody>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大曲げ M<sub>max</sub> (+)</td>
                                                <td className="p-1 font-mono font-bold">{sb.maxM.toFixed(2)} kN·m</td>
                                                <td className="p-1 font-mono">{(sb.maxM_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 font-mono">{(Math.abs(sb.maxM) * 1e6 / sectionProps.Z).toFixed(0)}</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大曲げ M<sub>min</sub> (-)</td>
                                                <td className="p-1 font-mono font-bold">{sb.minM.toFixed(2)} kN·m</td>
                                                <td className="p-1 font-mono">{(sb.minM_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 font-mono">{(Math.abs(sb.minM) * 1e6 / sectionProps.Z).toFixed(0)}</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大せん断 Q<sub>max</sub> (+)</td>
                                                <td className="p-1 font-mono font-bold">{sb.maxQ.toFixed(2)} kN</td>
                                                <td className="p-1 font-mono">{(sb.maxQ_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大せん断 Q<sub>min</sub> (-)</td>
                                                <td className="p-1 font-mono font-bold">{sb.minQ.toFixed(2)} kN</td>
                                                <td className="p-1 font-mono">{(sb.minQ_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大変位 δ<sub>max</sub> (+)</td>
                                                <td className="p-1 font-mono font-bold">{sb.maxD.toFixed(2)} mm</td>
                                                <td className="p-1 font-mono">{(sb.maxD_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                             <tr>
                                                <td className="p-1 text-left pl-2">最大変位 δ<sub>min</sub> (-)</td>
                                                <td className="p-1 font-mono font-bold">{sb.minD.toFixed(2)} mm</td>
                                                <td className="p-1 font-mono">{(sb.minD_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                    </tbody>
                                </table>
                            </div>
                        );
                    })}
                    <div className="avoid-break mt-2 border rounded p-2 bg-slate-50">
                         <div className="text-xs font-bold text-slate-600 mb-1">支点反力一覧</div>
                         <div className="flex flex-wrap gap-4">
                            {results.reactions.map((r, i) => (
                                <div key={i} className="text-xs font-mono">
                                    R<sub>{r.label}</sub> = <strong>{r.val.toFixed(2)}</strong> kN <span className="text-slate-400">(@{r.x.toFixed(1)}m)</span>
                                </div>
                            ))}
                         </div>
                    </div>
                </div>
            </section>
            <section className="mb-4 avoid-break">
                <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">4. 応力図 (SFD, BMD, Deflection)</h2>
                <div className="border rounded p-2 flex justify-center bg-white">
                    <AdvancedVisualizer {...params} forceWidth={580} />
                </div>
            </section>
            <section className="page-break"　>
                <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">5. 計算結果詳細（スパン別）</h2>
                <div className="grid grid-cols-1 gap-4">
                    {spanRanges.map((range, sIdx) => {
                        const spanPoints = finalPoiData.filter(p => p.x >= range.start - 1e-4 && p.x <= range.end + 1e-4);
                        if (spanPoints.length === 0) return null;
                        return (
                            <div key={sIdx} className="avoid-break mb-2">
                                <div className="text-xs font-bold bg-slate-100 px-2 py-1 border-t border-l border-r rounded-t text-slate-700">
                                    径間 {sIdx + 1} ({String.fromCharCode(65+sIdx)} - {String.fromCharCode(65+sIdx+1)}) 
                                    <span className="font-normal ml-2 text-slate-500">L = {range.len.toFixed(2)}m</span>
                                </div>
                                <table className="w-full text-xs text-right border border-slate-200">
                                    <thead className="bg-slate-50 text-slate-600">
                                            <tr>
                                                <th className="p-1 border w-16 text-center">x (local)</th>
                                                <th className="p-1 border">せん断 Q (kN)</th>
                                                <th className="p-1 border">曲げ M (kN·m)</th>
                                                <th className="p-1 border">応力 σ (N/mm²)</th>
                                                <th className="p-1 border">たわみ δ (mm)</th>
                                            </tr>
                                    </thead>
                                    <tbody>
                                            {spanPoints.map((p, idx) => {
                                                const localX = Math.max(0, Math.min(range.len, p.x - range.start));
                                                const val = getResultAt(p.x, results, sectionProps, sIdx);
                                                return (
                                                    <tr key={idx} className="border-b">
                                                        <td className="p-1 border text-center font-mono bg-slate-50/50">{localX.toFixed(3)}</td>
                                                        <td className="p-1 border font-mono">{val?.Q?.toFixed(2)}</td>
                                                        <td className="p-1 border font-mono">{val?.M?.toFixed(2)}</td>
                                                        <td className="p-1 border font-mono">{val?.sigma?.toFixed(1)}</td>
                                                        <td className="p-1 border font-mono">{val?.deflection?.toFixed(2)}</td>
                                                    </tr>
                                                );
                                            })}
                                    </tbody>
                                </table>
                            </div>
                        );
                    })}
                </div>
            </section>
        </div>
    );
}

function solveGeneralBeam(spans, supports, loads, resolution, props) {
  const totalL = spans.reduce((a, b) => a + b, 0);
  const validSupportIndices = supports.map((s, i) => s !== 'free' ? i : -1).filter(i => i !== -1);
  if (validSupportIndices.length < 1) return generateEmptyResult();
  const idxStart = validSupportIndices[0];
  const idxEnd = validSupportIndices[validSupportIndices.length - 1];
  const spanLoads = spans.map(() => []);
  let cx = 0;
  spans.forEach((len, i) => {
    const sx = cx; const ex = cx + len;
    loads.forEach(l => {
      if (l.type === 'moment' && l.pos === 0 && supports[0] === 'fixed') { return; }
      if (l.type === 'moment' && l.pos === totalL && supports[supports.length - 1] === 'fixed') { return; }
      const lStart = l.pos;
      const lEnd = l.type === 'point' || l.type === 'moment' ? l.pos : l.pos + l.length;
      const oStart = Math.max(sx, lStart);
      const oEnd = Math.min(ex, lEnd);
      if ((oEnd > oStart + EPS) || ((l.type === 'point' || l.type === 'moment') && lStart >= sx - EPS && (i === spans.length-1 ? lStart <= ex + EPS : lStart < ex - EPS))) {
        let mag = l.mag; let magEnd = l.magEnd;
        if (l.type === 'trapezoid') {
           const slope = (l.magEnd - l.mag) / l.length;
           mag = l.mag + slope * (oStart - l.pos);
           magEnd = l.mag + slope * (oEnd - l.pos);
        }
        spanLoads[i].push({ ...l, pos: oStart - sx, length: oEnd - oStart, mag, magEnd });
      }
    });
    cx += len;
  });
  let M_start = 0; 
  if (idxStart > 0) {
    for (let i = 0; i < idxStart; i++) {
       const distToSupport = spans.slice(i+1, idxStart).reduce((a,b)=>a+b, 0);
       spanLoads[i].forEach(l => {
         if (l.type === 'moment') { M_start += l.mag; } else {
             const { totalForce, momentA } = getLoadIntegral(l);
             const xc = totalForce !== 0 ? momentA / totalForce : 0;
             const arm = (spans[i] - xc) + distToSupport;
             M_start -= totalForce * arm; 
         }
       });
    }
  }
  let M_end = 0;
  if (idxEnd < spans.length) {
    for (let i = idxEnd; i < spans.length; i++) {
       const distToSupport = spans.slice(idxEnd, i).reduce((a,b)=>a+b, 0);
       spanLoads[i].forEach(l => {
         if (l.type === 'moment') { M_end -= l.mag; } else {
             const { totalForce, momentA } = getLoadIntegral(l);
             const xc = totalForce !== 0 ? momentA / totalForce : 0;
             const arm = distToSupport + xc;
             M_end -= totalForce * arm;
         }
       });
    }
  }
  const numNodes = idxEnd - idxStart + 1;
  const nodeMoments = new Array(spans.length + 1).fill(0);
  if (numNodes <= 1) {
    if (idxStart === idxEnd) nodeMoments[idxStart] = M_start + M_end;
  } else {
    const matrixSize = numNodes;
    const A = Array.from({ length: matrixSize }, () => Array(matrixSize).fill(0));
    const B = Array(matrixSize).fill(0);
    for (let k = 0; k < numNodes; k++) {
      const nodeIdx = idxStart + k;
      const supportType = supports[nodeIdx]; 
      const leftSpanIdx = nodeIdx - 1;
      const rightSpanIdx = nodeIdx;
      const phiL_load = (leftSpanIdx >= idxStart) ? calcPhi(spans[leftSpanIdx], spanLoads[leftSpanIdx]).phiR : 0;
      const phiR_load = (rightSpanIdx < idxEnd) ? calcPhi(spans[rightSpanIdx], spanLoads[rightSpanIdx]).phiL : 0;
      if (k === 0) {
        if (supportType === 'fixed') {
          A[k][k] = 2 * spans[rightSpanIdx];
          if (numNodes > 1) A[k][k+1] = spans[rightSpanIdx];
          B[k] = -6 * phiR_load;
        } else { A[k][k] = 1; B[k] = M_start; }
      } else if (k === numNodes - 1) {
        if (supportType === 'fixed') {
          const len = spans[leftSpanIdx];
          A[k][k-1] = len; A[k][k] = 2 * len;
          B[k] = -6 * phiL_load;
        } else { A[k][k] = 1; B[k] = M_end; }
      } else {
        A[k][k-1] = spans[leftSpanIdx];
        A[k][k] = 2 * (spans[leftSpanIdx] + spans[rightSpanIdx]);
        A[k][k+1] = spans[rightSpanIdx];
        B[k] = -6 * (phiL_load + phiR_load);
      }
    }
    const M_solutions = solveLinearSystem(A, B);
    for(let k=0; k<numNodes; k++) {
      nodeMoments[idxStart + k] = M_solutions[k];
    }
  }
  const shearData = []; const momentData = []; let globalX = 0;
  for (let i = 0; i < spans.length; i++) {
    const len = spans[i]; const sLoads = spanLoads[i]; const ML = nodeMoments[i]; const MR = nodeMoments[i+1];
    const keyPoints = new Set([0, len]);
    sLoads.forEach(l => { 
        keyPoints.add(l.pos); 
        if (l.type === 'moment') { keyPoints.add(Math.max(0, l.pos - 1e-6)); keyPoints.add(Math.min(len, l.pos + 1e-6)); } 
        else if(l.type !== 'point') { keyPoints.add(l.pos + l.length); }
    });
    const steps = Math.max(50, Math.min(Math.ceil(len * 200), 2000));
    for(let k=0; k<=steps; k++) keyPoints.add(k * (len / steps));
    const sortedLx = Array.from(keyPoints).sort((a,b)=>a-b);
    let sumP=0, sumM=0;
    sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
    const Rb_s = sumM/len; const Ra_s = sumP - Rb_s;
    sortedLx.forEach(lx => {
        const gx = globalX + lx; const Qb = (MR - ML) / len;
        const Q_left = getSectionForceSimple(lx, sLoads, Ra_s, 'left').Q + Qb;
        const Q_right = getSectionForceSimple(lx, sLoads, Ra_s, 'right').Q + Qb;
        shearData.push({ x: gx, y: Q_left });
        if (Math.abs(Q_left - Q_right) > 1e-6) { shearData.push({ x: gx, y: Q_right }); }
        const Ms = getSectionForceSimple(lx, sLoads, Ra_s).M;
        const Mb = ML + (MR - ML) * (lx / len);
        momentData.push({ x: gx, y: Ms + Mb });
    });
    globalX += len;
  }
  const deflectionData = []; const rawIntegration = []; let curTh = 0, curY = 0;
  rawIntegration.push({ x: 0, th: 0, y: 0 });
  for (let j = 0; j < momentData.length - 1; j++) {
      const p1 = momentData[j], p2 = momentData[j+1];
      const dx = p2.x - p1.x;
      if (dx < 1e-8) continue;
      const phi1 = -(p1.y * 1e6) / (props.E * props.I);
      const phi2 = -(p2.y * 1e6) / (props.E * props.I);
      const dTh = (phi1 + phi2) * 0.5 * dx * 1000;
      const dY = (curTh + (curTh + dTh)) * 0.5 * dx * 1000;
      curTh += dTh; curY += dY;
      rawIntegration.push({ x: p2.x, th: curTh, y: curY });
  }
  let C1 = 0, C2 = 0;
  const getRaw = (x) => {
      const match = rawIntegration.find(p => Math.abs(p.x - x) < 1e-4);
      if (match) return match;
      const low = rawIntegration.filter(p => p.x <= x).pop();
      const high = rawIntegration.find(p => p.x > x);
      if (!low || !high) return low || high || { th: 0, y: 0 };
      const r = (x - low.x) / (high.x - low.x);
      return { th: low.th + (high.th - low.th) * r, y: low.y + (high.y - low.y) * r };
  };
  const supportPoints = []; let tx = 0;
  supports.forEach((s, i) => {
      if (s !== 'free') supportPoints.push({ x: tx, type: s });
      if (i < spans.length) tx += spans[i];
  });
  if (supportPoints.length > 0) {
      const firstS = supportPoints[0];
      if (firstS.type === 'fixed') {
          const raw = getRaw(firstS.x); C1 = -raw.th; C2 = -raw.y - C1 * firstS.x;
      } else if (supportPoints.length >= 2) {
          const s1 = supportPoints[0], s2 = supportPoints[supportPoints.length - 1];
          const r1 = getRaw(s1.x), r2 = getRaw(s2.x);
          C1 = -(r2.y - r1.y) / (s2.x - s1.x); C2 = -r1.y - C1 * s1.x;
      } else { const r1 = getRaw(firstS.x); C1 = 0; C2 = -r1.y; }
  }
  rawIntegration.forEach(p => { deflectionData.push({ x: p.x, y: p.y + C1 * p.x + C2 }); });
  const spanBounds = []; let sx = 0;
  for (let i = 0; i < spans.length; i++) {
    const ex = sx + spans[i];
    const sLoads = spanLoads[i];
    let sumP=0, sumM=0;
    sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
    const len = spans[i]; const Rb_s = sumM/len; const Ra_s = sumP - Rb_s;
    const ML = nodeMoments[i]; const MR = nodeMoments[i+1]; const Qb = (MR - ML) / len;
    const zeroCrossX = []; const checkStep = 50; 
    for(let k=0; k<checkStep; k++) {
        const x1 = (k/checkStep)*len; const x2 = ((k+1)/checkStep)*len;
        const Q1 = getSectionForceSimple(x1, sLoads, Ra_s).Q + Qb;
        const Q2 = getSectionForceSimple(x2, sLoads, Ra_s).Q + Qb;
        if(Q1 * Q2 < 0) { const x0 = x1 + (0 - Q1) * (x2 - x1) / (Q2 - Q1); zeroCrossX.push(x0); }
    }
    const sM_points = momentData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    const sQ_points = shearData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    const sD_points = deflectionData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    zeroCrossX.forEach(zx => {
        const gx = sx + zx;
        const res = getSectionForceSimple(zx, sLoads, Ra_s);
        const Mb = ML + (MR - ML) * (zx / len);
        sM_points.push({ x: gx, y: res.M + Mb });
    });
    const maxM = Math.max(...sM_points.map(d => d.y)), minM = Math.min(...sM_points.map(d => d.y));
    const maxQ = Math.max(...sQ_points.map(d => d.y)), minQ = Math.min(...sQ_points.map(d => d.y));
    const maxD = Math.max(...sD_points.map(d => d.y)), minD = Math.min(...sD_points.map(d => d.y));
    spanBounds.push({
      spanIndex: i, 
      maxM, maxM_x: sM_points.find(d => d.y === maxM)?.x || sx,
      minM, minM_x: sM_points.find(d => d.y === minM)?.x || sx,
      maxQ, maxQ_x: sQ_points.find(d => d.y === maxQ)?.x || sx,
      minQ, minQ_x: sQ_points.find(d => d.y === minQ)?.x || sx,
      maxD, maxD_x: sD_points.find(d => d.y === maxD)?.x || sx,
      minD, minD_x: sD_points.find(d => d.y === minD)?.x || sx
    });
    sx = ex;
  }
  const reactions = [];
  validSupportIndices.forEach(idx => {
    let pos = 0; for(let k=0; k<idx; k++) pos += spans[k];
    let R_val = 0;
    if (idx > 0) {
        const i = idx - 1; const len = spans[i]; const sLoads = spanLoads[i];
        let sumP=0, sumM=0; sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
        const Rb_simple = sumM/len; 
        const ML = nodeMoments[i]; const MR = nodeMoments[i+1]; const Q_mom = (MR - ML) / len; 
        R_val += (Rb_simple - Q_mom);
    }
    if (idx < spans.length) {
        const i = idx; const len = spans[i]; const sLoads = spanLoads[i];
        let sumP=0, sumM=0; sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
        const Rb_simple = sumM/len; const Ra_simple = sumP - Rb_simple;
        const ML = nodeMoments[i]; const MR = nodeMoments[i+1]; const Q_mom = (MR - ML) / len;
        R_val += (Ra_simple + Q_mom);
    }
    reactions.push({ x: pos, val: R_val, label: String.fromCharCode(65+idx) });
  });
  const maxM_pos = Math.max(0, ...momentData.map(d=>d.y));
  const maxM_neg = Math.min(0, ...momentData.map(d=>d.y));
  return {
    shearData, momentData, deflectionData, spanBounds, reactions,
    raw: { spans, spanLoads, nodeMoments, supports },
    bounds: { 
      maxShear: Math.max(...shearData.map(d=>Math.abs(d.y))), maxShear_x: 0,
      maxM_pos, maxM_pos_x: momentData.find(d=>d.y===maxM_pos)?.x || 0,
      maxM_neg, maxM_neg_x: momentData.find(d=>d.y===maxM_neg)?.x || 0,
      maxDeflection: Math.max(...deflectionData.map(d=>Math.abs(d.y))), 
      maxDef_x: deflectionData.find(d=>Math.abs(d.y) === Math.max(...deflectionData.map(v=>Math.abs(v.y))))?.x || 0,
      maxSigma_pos: maxM_pos * 1e6 / props.Z,
      maxSigma_neg: maxM_neg * 1e6 / props.Z
    },
  };
}

function getResultAt(x, results, props, targetSpanIndex = -1) {
    if (!results.momentData) return {};
    if (results.raw) {
        const { spans, spanLoads, nodeMoments, supports } = results.raw;
        let currentX = 0; let spanIndex = -1; let localX = 0;
        if (targetSpanIndex !== -1 && targetSpanIndex >= 0 && targetSpanIndex < spans.length) {
            for(let k=0; k<targetSpanIndex; k++) currentX += spans[k];
            spanIndex = targetSpanIndex; localX = x - currentX;
            if(localX < 0 && localX > -0.001) localX = 0;
            if(localX > spans[spanIndex] && localX < spans[spanIndex] + 0.001) localX = spans[spanIndex];
        } else {
            for(let i=0; i<spans.length; i++) {
                if (x >= currentX - 1e-9 && x <= currentX + spans[i] + 1e-9) {
                    spanIndex = i; localX = x - currentX;
                    if(localX < 0) localX = 0; if(localX > spans[i]) localX = spans[i];
                    break;
                }
                currentX += spans[i];
            }
        }
        if (spanIndex !== -1) {
            const len = spans[spanIndex]; const loads = spanLoads[spanIndex];
            const ML = nodeMoments[spanIndex]; const MR = nodeMoments[spanIndex + 1];
            let sumP=0, sumM=0; loads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
            const Rb_simple = sumM/len; const Ra_simple = sumP - Rb_simple;
            const simpleRes = getSectionForceSimple(localX, loads, Ra_simple, 'right');
            const Qb = (MR - ML) / len; const Mb = ML + (MR - ML) * (localX / len);
            const totalQ = simpleRes.Q + Qb; let totalM = simpleRes.M + Mb;
            const totalLen = spans.reduce((a,b)=>a+b, 0);
            const rightSupport = supports[supports.length - 1];
            const isTargetSupport = ['free', 'pin', 'roller'].includes(rightSupport);
            if (Math.abs(x - totalLen) < 0.001 && isTargetSupport) {
                const lastSpanIdx = spans.length - 1; const lastSpanLoads = spanLoads[lastSpanIdx]; const lastSpanLen = spans[lastSpanIdx];
                let endMomentSum = 0;
                lastSpanLoads.forEach(l => { if (l.type === 'moment' && Math.abs(l.pos - lastSpanLen) < 0.001) { endMomentSum += l.mag; } });
                if (endMomentSum !== 0) { totalM += (-endMomentSum); }
            }
            let defVal = 0;
            if (results.deflectionData) {
                 const arr = results.deflectionData; const match = arr.find(p => Math.abs(p.x - x) < 1e-4);
                 if (match) defVal = match.y; else {
                     const low = arr.filter(p => p.x <= x).pop(); const high = arr.find(p => p.x > x);
                     if (low && high) { defVal = low.y + (high.y - low.y) * ((x - low.x)/(high.x - low.x)); } else { defVal = low ? low.y : (high ? high.y : 0); }
                 }
            }
            let supX = 0; let isNearSupport = false;
            for(let i=0; i<supports.length; i++) {
                if (supports[i] !== 'free') { if (Math.abs(x - supX) < 0.001) { isNearSupport = true; break; } }
                if (i < spans.length) supX += spans[i];
            }
            if (isNearSupport) defVal = 0;
            return { Q: totalQ, M: totalM, deflection: defVal, sigma: Math.abs(totalM * 1e6 / props.Z) };
        }
    }
    const getVal = (arr) => {
        if (!arr || arr.length === 0) return 0;
        const match = arr.find(p => Math.abs(p.x - x) < 1e-4);
        if (match) return match.y;
        const low = arr.filter(p => p.x <= x).pop(); const high = arr.find(p => p.x > x);
        if (low && high) { return low.y + (high.y - low.y) * ((x - low.x)/(high.x - low.x)); }
        return low ? low.y : (high ? high.y : 0);
    };
    const M = getVal(results.momentData);
    return { Q: getVal(results.shearData), M: M, deflection: getVal(results.deflectionData), sigma: Math.abs(M * 1e6 / props.Z) };
}

function getSectionForceSimple(x, loads, Ra, side='left') {
  let Q = Ra, M = Ra * x;
  loads.forEach(l => {
    if (l.pos > x + EPS) return;
    if ((l.type === 'point' || l.type === 'moment') && Math.abs(l.pos - x) < EPS && side === 'left') return;
    let endPos = l.pos + l.length, effectiveLen = Math.max(0, Math.min(x, endPos) - l.pos);
    if (effectiveLen < EPS && l.type !== 'point' && l.type !== 'moment') return;
    let pLoad = { ...l, length: effectiveLen };
    if (l.type === 'trapezoid') pLoad.magEnd = l.mag + (l.magEnd - l.mag) * effectiveLen / l.length;
    if (l.type === 'moment') { M += l.mag; } else {
        const r = getLoadIntegral(pLoad); Q -= r.totalForce; M -= (x * r.totalForce - r.momentA);
    }
  });
  return { Q, M };
}

function getLoadIntegral(l) {
  if (l.type === 'point') return { totalForce: l.mag, momentA: l.mag * l.pos };
  if (l.type === 'moment') return { totalForce: 0, momentA: l.mag }; 
  const w1=l.mag, w2=l.type==='trapezoid'?l.magEnd:l.mag, L=l.length;
  if (L <= 0) return { totalForce: 0, momentA: 0 };
  const F = L*(w1+w2)/2, distC = (w1+w2)===0 ? L/2 : (L/3) * (w1 + 2*w2) / (w1+w2); 
  return { totalForce: F, momentA: F * (l.pos + distC) };
}

function calcPhi(L, loads) {
  let phiL = 0, phiR = 0; const stepsPerMeter = 1000;
  const N = Math.min(Math.max(50, Math.ceil(L * stepsPerMeter)), 10000); 
  const dx = L/N;
  let sumP=0, sumM=0; loads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
  const Rb = sumM/L, Ra = sumP - Rb;
  for(let i=0; i<N; i++) {
    const x = (i+0.5)*dx, M = getSectionForceSimple(x, loads, Ra).M;
    phiL += (M * (L-x)/L) * dx; phiR += (M * x/L) * dx;
  }
  return { phiL, phiR };
}

function solveLinearSystem(A, B) {
  const n = B.length;
  for (let i = 0; i < n; i++) {
    let maxEl = Math.abs(A[i][i]), maxRow = i;
    for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > maxEl) { maxEl = Math.abs(A[k][i]); maxRow = k; }
    for (let k = i; k < n; k++) [A[maxRow][k], A[i][k]] = [A[i][k], A[maxRow][k]];
    [B[maxRow], B[i]] = [B[i], B[maxRow]];
    for (let k = i + 1; k < n; k++) {
      const c = -A[k][i] / A[i][i];
      for (let j = i; j < n; j++) A[k][j] = (i === j ? 0 : A[k][j] + c * A[i][j]);
      B[k] += c * B[i];
    }
  }
  const x = new Array(n).fill(0);
  for (let i = n - 1; i > -1; i--) {
    let sum = 0; for (let k = i + 1; k < n; k++) sum += A[i][k] * x[k];
    x[i] = (B[i] - sum) / A[i][i];
  }
  return x;
}

function generateEmptyResult() {
  return { shearData:[], momentData:[], deflectionData:[], poiResults:[], spanBounds:[], reactions:[], bounds:{ maxShear:0, maxM_pos:0, maxM_neg:0, maxDeflection:0, maxSigma_pos:0, maxSigma_neg:0 } };
}

// --- Visual Components ---
function SectionProfileView({ props }) {
  const { shape, dims, axis, matType, isManualMode } = props;
  const size = 100, scale = 0.8;
  const cx = size / 2, cy = size / 2;
  let pathD = "";
  if (matType === 'manual') {
      const H=s(200), B=s(100), t1=s(6), t2=s(8);
      pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)/2} v ${H-2*t2} h ${(B-t1)/2} v ${t2} h ${-B} v ${-t2} h ${(B-t1)/2} v ${-(H-2*t2)} h ${-(B-t1)/2} z`;
      return <svg width="100%" height="100%" viewBox="0 0 100 100"><path d={pathD} fill="#e2e8f0" stroke="#94a3b8" strokeWidth="1.5" strokeDasharray="3" /><text x={50} y={50} textAnchor="middle" fontSize="10" fill="#64748b" dominantBaseline="middle">Manual</text></svg>;
  }
  if (!dims.H) return null;
  const maxDim = Math.max(dims.H, dims.B);
  function s(v) { return (v / maxDim) * size * scale; }
  if (matType === 'concrete') {
    const w = s(dims.B), h = s(dims.H); 
    pathD = `M ${cx-w/2} ${cy-h/2} h ${w} v ${h} h ${-w} z`;
    return (
      <svg width="100%" height="100%" viewBox="0 0 100 100">
        <path d={pathD} fill="#cbd5e1" stroke="#475569" strokeWidth="1.5" />
        <text x={cx} y={cy+h/2+10} textAnchor="middle" fontSize="8" fill="#475569">b={dims.B}</text>
        <text x={cx+w/2+2} y={cy} textAnchor="start" fontSize="8" fill="#475569">D={dims.H}</text>
      </svg>
    );
  } else {
    const H = s(dims.H), B = s(dims.B), t1 = s(dims.t1), t2 = s(dims.t2), C = s(dims.C_lip || 0);
    if (shape === 'H') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)/2} v ${H-2*t2} h ${(B-t1)/2} v ${t2} h ${-B} v ${-t2} h ${(B-t1)/2} v ${-(H-2*t2)} h ${-(B-t1)/2} z`;
    else if (shape === 'Channel') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)} v ${H-2*t2} h ${B-t1} v ${t2} h ${-B} z`;
    else if (shape === 'Angle') pathD = `M ${cx-B/2} ${cy-H/2} v ${H} h ${B} v ${-t2} h ${-(B-t1)} v ${-(H-t2)} z`;
    else if (shape === 'LipChannel') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${C} h ${-t2} v ${-(C-t2)} h ${-(B-t1-t2)} v ${H-2*t2} h ${B-t1-t2} v ${-(C-t2)} h ${t2} v ${C} h ${-B} z`;
    else if (shape.includes('SheetPile')) { const dH = H, dB = B, dt = t1; pathD = `M ${cx-dB/2} ${cy-dH/2} v ${dH} h ${dB} v ${-dH} h ${-dt} v ${dH-dt} h ${-(dB-2*dt)} v ${-(dH-dt)} z`; }
    else if (shape === 'SquarePipe') { const dH = H, dB = B, dt = t1; pathD = `M ${cx-dB/2} ${cy-dH/2} h ${dB} v ${dH} h ${-dB} z M ${cx-(dB-2*dt)/2} ${cy-(dH-2*dt)/2} v ${dH-2*dt} h ${dB-2*dt} v ${-(dH-2*dt)} z`; }
  }
  return <svg width="100%" height="100%" viewBox="0 0 100 100"><path d={pathD} fill="#cbd5e1" stroke="#475569" strokeWidth="1.5" fillRule="evenodd" transform={axis === 'weak' ? `rotate(90, ${cx}, ${cy})` : ''} /></svg>;
}

// Reactアプリのマウント
const root = createRoot(document.getElementById('root'));
root.render(<App />);

</script>
</body>
</html>
