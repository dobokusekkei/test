<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>構造計算アプリケーション v21.30</title>

<script src="https://cdn.tailwindcss.com"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom/server": "https://esm.sh/react-dom@18.2.0/server",
    "lucide-react": "https://esm.sh/lucide-react@0.294.0"
  }
}
</script>

<script src="https://unpkg.com/@babel/standalone@7.23.9/babel.min.js"></script>

<link rel="stylesheet" href="css/style.css">

<script src="js/materials.js"></script>

</head>

<body class="bg-slate-50 text-slate-800">
<div id="root"></div>

<script type="text/babel" data-type="module">
import React, { useState, useMemo, useEffect, useRef } from 'react';
import { createRoot } from 'react-dom/client';
import { createPortal } from 'react-dom';
import { renderToStaticMarkup } from 'react-dom/server';
import { Plus, Trash2, Activity, Settings, List, X, Layers, ChevronDown, ArrowRight, RotateCw, AlertTriangle, Save, FolderOpen, Printer, Edit3, HelpCircle, History, FileDown, Upload, ExternalLink } from 'lucide-react';

/**
 * ==========================================
 * [決定版] 構造計算アプリケーション v21.30
 * ==========================================
 */

// ▼▼▼ ここから書き換え開始 ▼▼▼

// 元のコードにあった長い定数定義（STEEL_DBなど）はすべて消して、
// 以下の「window受け取りコード」に置き換えてください。

const INITIAL_SPAN = window.INITIAL_SPAN;
const RESOLUTION = window.RESOLUTION;
const E_STEEL = window.E_STEEL;
const EPS = window.EPS;

const STEEL_DB = window.STEEL_DB;
const STEEL_LISTS = window.STEEL_LISTS;
const CONCRETE_STRENGTHS = window.CONCRETE_STRENGTHS;
const COLORS = window.COLORS;
const BEAM_TYPES = window.BEAM_TYPES;

const HISTORY_DATA = window.HISTORY_DATA;
const MANUAL_SECTIONS = window.MANUAL_SECTIONS;

/**
 * 別ウィンドウ管理用コンポーネント
 * (React Portalを使用して新しいウィンドウにコンテンツを描画)
 */
function NewWindow({ children, onClose, title = "計算結果詳細" }) {
  const newWindow = useRef(null);
  const [container, setContainer] = useState(null);

  useEffect(() => {
    // ウィンドウを開く
    const win = window.open("", "_blank", "width=1000,height=800,left=100,top=100");
    if (!win) {
      alert("ポップアップがブロックされました。許可してください。");
      if (onClose) onClose();
      return;
    }
    
    newWindow.current = win;
    win.document.title = title;

    // 親ウィンドウのスタイルシート(CSS)をすべてコピーする
    // (これがないと別ウィンドウが真っ白や崩れた表示になります)
    Array.from(document.styleSheets).forEach(styleSheet => {
      try {
        if (styleSheet.href) {
          const newLink = win.document.createElement('link');
          newLink.rel = 'stylesheet';
          newLink.href = styleSheet.href;
          win.document.head.appendChild(newLink);
        } else if (styleSheet.cssRules) {
          const newStyle = win.document.createElement('style');
          Array.from(styleSheet.cssRules).forEach(rule => {
            newStyle.appendChild(win.document.createTextNode(rule.cssText));
          });
          win.document.head.appendChild(newStyle);
        }
      } catch (e) {
        // CORS制限などでコピーできないスタイルは無視
      }
    });

    // TailwindなどのCDNスクリプトもコピー
    Array.from(document.scripts).forEach(script => {
        if (script.src && !script.src.includes('babel')) { // Babelはコピーしない
            const newScript = win.document.createElement('script');
            newScript.src = script.src;
            win.document.head.appendChild(newScript);
        }
    });

    // コンテンツを描画するdivを作成
    const div = win.document.createElement('div');
    // 印刷時に余白などをリセットするクラスを付与
    div.className = "p-4 min-h-screen bg-white";
    win.document.body.appendChild(div);
    win.document.body.className = "bg-slate-50"; // 背景色設定

    setContainer(div);

    // ウィンドウが閉じられた時の処理
    win.onbeforeunload = () => {
      if (onClose) onClose();
    };

    // クリーンアップ
    return () => {
      if (newWindow.current) {
        newWindow.current.close();
      }
    };
  }, []);

  // Portalを使って新しいウィンドウのdivにchildrenを描画
  return container ? createPortal(children, container) : null;
}

// ▲▲▲ 書き換え終了（これより下の function App() ... などは消さないで！） ▲▲▲
// [145行目] return container ? createPortal(children, container) : null;
// [146行目] }
// [147行目] // ▲▲▲ 書き換え終了...

// ★ここに以下のコードを挿入してください
function ResultContent({ results, sectionProps, loads, spans, supports, totalLength, finalPoiData, userPoi, setUserPoi }) {
    return (
        <div className="space-y-6">
            <div className="flex justify-between items-end border-b pb-2">
                <div>
                    <h2 className="text-xl font-bold text-slate-800">計算結果詳細ビュー</h2>
                    <p className="text-sm text-slate-500">断面: {sectionProps.label} / 全長: {totalLength.toFixed(2)}m</p>
                </div>
                <div className="text-right text-xs text-slate-400">
                    ※このウィンドウは印刷用に最適化されていません。<br/>印刷には親画面の「印刷」ボタンを使用してください。
                </div>
            </div>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <ResultBox label="最大M (+)" val={results.bounds.maxM_pos} x={results.bounds.maxM_pos_x} unit="kN·m" color="text-emerald-600" />
                <ResultBox label="最大M (-)" val={results.bounds.maxM_neg} x={results.bounds.maxM_neg_x} unit="kN·m" color="text-red-600" />
                <ResultBox label="最大たわみ" val={results.bounds.maxDeflection} x={results.bounds.maxDef_x} unit="mm" color="text-blue-600" />
                <ResultBox label="最大せん断" val={results.bounds.maxShear} x={results.bounds.maxShear_x} unit="kN" color="text-amber-600" />
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h3 className="font-bold text-slate-600 mb-4">応力図・変位図</h3>
                <AdvancedVisualizer spans={spans} supports={supports} totalLength={totalLength} loads={loads} results={results} />
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <PoiTable 
                    finalPoiData={finalPoiData} 
                    userPoi={userPoi} 
                    setUserPoi={setUserPoi} 
                    totalLength={totalLength} 
                    spans={spans} 
                    results={results}
                    sectionProps={sectionProps}
                />
            </div>
        </div>
    );
}
// ★挿入ここまで

// [150行目付近] // ... (以下、元のコードが続く) ...
// [152行目付近] function App() {

// ... (以下、元のコードが続く) ...

function App() {
  // --- States ---
  const [spanStr, setSpanStr] = useState(INITIAL_SPAN);
  const [beamType, setBeamType] = useState('simple');
  const [loads, setLoads] = useState([{ id: 1, type: 'point', mag: 10, pos: 3, length: 0 }]);
  const [showHelp, setShowHelp] = useState(false); // Help Modal State
  const [showHistory, setShowHistory] = useState(false); // Version History Modal State
  const [showResultWindow, setShowResultWindow] = useState(false);
    
  // ★[MODIFIED] matType: steel | concrete | manual
  const [matType, setMatType] = useState('steel');
  const [steelShape, setSteelShape] = useState('H');
  const [steelProfileIdx, setSteelProfileIdx] = useState(9); 
  const [steelAxis, setSteelAxis] = useState('strong');
    
  // New: Manual Input States
  const [manualI, setManualI] = useState("1000"); // cm4
  const [manualZ, setManualZ] = useState("100");  // cm3
  const [manualA, setManualA] = useState("30.0"); // cm2
  const [manualE, setManualE] = useState("205"); // kN/mm2 (205000 N/mm2)
    
  const [effI, setEffI] = useState("1.0"); 
  const [effZ, setEffZ] = useState("1.0");
  const [wallLength, setWallLength] = useState("1.0"); // 施工延長(m)

  const [rcFcIdx, setRcFcIdx] = useState(1);
  const [rcWidthStr, setRcWidthStr] = useState('300');
  const [rcDepthStr, setRcDepthStr] = useState('600');

  const [userPoi, setUserPoi] = useState([]); 

  const [newLoadType, setNewLoadType] = useState('point');
  const [newMagStart, setNewMagStart] = useState(10);
  const [newMagEnd, setNewMagEnd] = useState(10);
  const [newPos, setNewPos] = useState(0);
  const [newLength, setNewLength] = useState(2);

  const [calcError, setCalcError] = useState(null);

  const fileInputRef = useRef(null);

  // --- 解析モデルの計算 ---
  const { spans, totalLength, supports } = useMemo(() => {
    const vals = normalizeText(spanStr).replace(/,/g, ' ').split(/\s+/).map(Number).filter(n => !isNaN(n) && n > 0);
    const safeVals = vals.length > 0 ? vals : [6.0];
    let s = safeVals;
    let supp = [];

    switch (beamType) {
      case 'simple': s = [safeVals[0]]; supp = ['pin', 'roller']; break;
      case 'fixed': s = [safeVals[0]]; supp = ['fixed', 'fixed']; break;
      case 'cantilever': s = [safeVals[0]]; supp = ['fixed', 'free']; break;
      case 'overhang_one': 
        if(s.length < 2) s = [s[0], s[0]*0.3]; 
        s = s.slice(0, 2); supp = ['pin', 'roller', 'free']; break;
      case 'overhang_both': 
        if(s.length < 3) { const main = s.length>=2?s[1]:s[0]; const sub = s.length>=1?s[0]:2.0; s = [sub, main, sub]; }
        s = s.slice(0, 3); supp = ['free', 'pin', 'roller', 'free']; break;
      case 'continuous2': 
        if(s.length < 2) s = [s[0], s[0]];
        s = s.slice(0, 2); supp = ['pin', 'roller', 'roller']; break;
      case 'continuous2_overhang': 
        if(s.length < 3) s = [s[0], s[0], s[0]*0.3];
        s = s.slice(0, 3); supp = ['pin', 'roller', 'roller', 'free']; break;
      case 'continuous3': 
        if(s.length < 3) s = [s[0], s[0], s[0]];
        s = s.slice(0, 3); supp = ['pin', 'roller', 'roller', 'roller']; break;
      default: s = [6.0]; supp = ['pin', 'roller'];
    }
    return { spans: s, totalLength: s.reduce((a,b)=>a+b, 0), supports: supp };
  }, [spanStr, beamType]);

  // --- 断面性能の取得 ---
  const sectionProps = useMemo(() => {
    let E = 0, I = 0, Z = 0, label = '', dims = {}, A = 0, w = 0;
    
    // ★[MODIFIED] Manual Mode Logic
    if (matType === 'manual') {
        const iVal = parseFloat(manualI);
        const zVal = parseFloat(manualZ);
        const aVal = parseFloat(manualA);
        const eVal = parseFloat(manualE);

        I = (isNaN(iVal) ? 0 : iVal) * 10000; // cm4 -> mm4
        Z = (isNaN(zVal) ? 0 : zVal) * 1000;  // cm3 -> mm3
        A = (isNaN(aVal) ? 0 : aVal);         // cm2
        E = (isNaN(eVal) ? 0 : eVal) * 1000;  // kN/mm2 -> N/mm2

        w = A * 0.785; // Default assumption for weight calc (Steel approx)
        label = `任意断面 (I=${manualI}, Z=${manualZ})`;
        dims = { type: 'manual' }; 
    
    } else if (matType === 'steel') {
      E = E_STEEL; 
      const list = STEEL_LISTS[steelShape];
      const name = list[steelProfileIdx] || list[0];
      const props = getSteelProps(steelShape, name, steelAxis);
      dims = props;

      if (steelShape.includes('SheetPile')) {
          const wVal = parseFloat(wallLength);
          const safeWL = (isNaN(wVal) || wVal <= 0) ? 1.0 : wVal;
          const iVal = parseFloat(effI);
          const safeEffI = (isNaN(iVal) || iVal < 0) ? 1.0 : iVal;
          const zVal = parseFloat(effZ);
          const safeEffZ = (isNaN(zVal) || zVal < 0) ? 1.0 : zVal;

          I = props.I * safeEffI * safeWL;
          Z = props.Z * safeEffZ * safeWL;
          A = props.A * safeWL;
          w = props.w * safeWL;
          label = `${name} (L=${safeWL}m)`;
      } else {
          I = props.I; 
          Z = props.Z;
          A = props.A;
          w = props.w;
          label = `${name} (${steelAxis === 'strong' ? '強軸' : '弱軸'})`;
      }

    } else {
      const fcData = CONCRETE_STRENGTHS[rcFcIdx];
      const b = parseFloat(rcWidthStr) || 0;
      const D = parseFloat(rcDepthStr) || 0;
      E = fcData.Ec; I = (b * Math.pow(D, 3)) / 12; Z = (b * Math.pow(D, 2)) / 6; 
      dims = { H: D, B: b, type: 'RC' };
      const areaM2 = (b/1000)*(D/1000);
      A = areaM2 * 10000; // cm2
      w = areaM2 * 2400; // kg/m
      label = `RC造 ${fcData.label} ${b}x${D}`;
    }
    return { E, I, Z, label, dims, shape: steelShape, axis: steelAxis, matType, effI, effZ, wallLength, A, w };
  }, [matType, steelShape, steelProfileIdx, steelAxis, rcFcIdx, rcWidthStr, rcDepthStr, effI, effZ, wallLength, manualI, manualZ, manualA, manualE]);

  // --- 構造解析実行 ---
  const results = useMemo(() => {
    try {
      setCalcError(null);
      return solveGeneralBeam(spans, supports, loads, RESOLUTION, sectionProps);
    } catch (e) {
      console.error(e);
      setCalcError("解析エンジンでエラーが発生しました。入力を確認してください。");
      return generateEmptyResult();
    }
  }, [spans, supports, loads, sectionProps]);

  // --- 自動着目点(POI)の算出 ---
  const autoPoiPoints = useMemo(() => {
    if(!results.bounds) return [];
    
    // ★Fix: 座標の丸め関数 (3桁精度で管理して数値誤差による重複を防ぐ)
    const R = (v) => Math.round(v * 1000) / 1000;
    const points = new Set();
    
    points.add(R(0));
    points.add(R(totalLength));
    
    let cx = 0;
    spans.forEach(s => { cx += s; points.add(R(cx)); });

    loads.forEach(l => {
        points.add(R(l.pos));
        // ★[MODIFIED] Add discontinuity points for Moment load
        if (l.type === 'moment') {
            points.add(R(Math.max(0, l.pos - 1e-6)));
            points.add(R(Math.min(totalLength, l.pos + 1e-6)));
        } else if(l.type !== 'point') {
            points.add(R(l.pos + l.length));
        }
    });

    if (results.bounds) {
        const b = results.bounds;
        [b.maxShear_x, b.maxM_pos_x, b.maxM_neg_x, b.maxDef_x].forEach(x => { if (x !== undefined) points.add(R(x)); });
    }
    if (results.spanBounds) {
        results.spanBounds.forEach(sb => {
            [sb.maxM_x, sb.minM_x, sb.maxQ_x, sb.minQ_x, sb.maxD_x, sb.minD_x].forEach(x => { if (x !== undefined) points.add(R(x)); });
        });
    }

    // ゼロクロス点の追加
    const findZeroCrossings = (data) => {
        const crossings = [];
        if (!data) return crossings;
        for (let i = 1; i < data.length - 1; i++) {
            if (data[i].y * data[i+1].y < -1e-6) {
                const x = data[i].x + (0 - data[i].y) * (data[i+1].x - data[i].x) / (data[i+1].y - data[i].y);
                crossings.push(x);
            } 
            else if (Math.abs(data[i].y) < 1e-6) {
                const prevY = data[i-1].y;
                const nextY = data[i+1].y;
                if (Math.abs(prevY) > 1e-4 || Math.abs(nextY) > 1e-4) crossings.push(data[i].x);
            }
        }
        return crossings;
    };
    findZeroCrossings(results.momentData).forEach(x => points.add(R(x)));
    findZeroCrossings(results.shearData).forEach(x => points.add(R(x)));

    return Array.from(points)
      .filter(p => p >= 0 && p <= totalLength)
      .sort((a, b) => a - b);
  }, [totalLength, spans.join(','), loads, results.bounds]);

  // ★[MODIFIED] 最終的なPOIリスト（自動 + ユーザー）の作成
  const finalPoiData = useMemo(() => {
      const merged = [];
      // 自動点
      autoPoiPoints.forEach(x => merged.push({ type: 'auto', x, id: `auto-${x}` }));
      // ユーザー点
      userPoi.forEach(p => merged.push({ type: 'user', x: p.x, id: p.id }));
      
      // ソートして値を計算
      return merged.sort((a,b) => a.x - b.x).map(p => {
          return { ...p, res: getResultAt(p.x, results, sectionProps) };
      });
  }, [autoPoiPoints, userPoi, results, sectionProps]);

  // --- CSV Export Logic (v21.29 NEW) ---
  const exportToCSV = () => {
    // BOM付与 (Excel文字化け対策)
    let csvContent = "\uFEFF";
    
    // Header
    csvContent += `[INFO],Version,21.29,Date,${new Date().toLocaleDateString()}\n`;
    
    // Inputs (Wrap strings with quotes to handle commas)
    csvContent += `[INPUT_BASIC],SpanStr,"${spanStr}",BeamType,${beamType},MatType,${matType}\n`;
    
    // ★[MODIFIED] Output only relevant material inputs based on matType
    if (matType === 'steel') {
        csvContent += `[INPUT_STEEL],Shape,${steelShape},ProfileIdx,${steelProfileIdx},Axis,${steelAxis}\n`;
        // Pile inputs are part of steel group if selected
        if (steelShape.includes('SheetPile')) {
            csvContent += `[INPUT_PILE],EffI,${effI},EffZ,${effZ},WallLength,${wallLength}\n`;
        }
    } else if (matType === 'manual') {
        csvContent += `[INPUT_MANUAL],I,${manualI},Z,${manualZ},A,${manualA},E,${manualE}\n`;
    } else if (matType === 'concrete') {
        csvContent += `[INPUT_RC],FcIdx,${rcFcIdx},Width,${rcWidthStr},Depth,${rcDepthStr}\n`;
    }
    
    // Loads
    csvContent += `[HEADER_LOAD],Id,Type,Mag,Pos,Length,MagEnd\n`;
    loads.forEach(l => {
        csvContent += `[LOAD],${l.id},${l.type},${l.mag},${l.pos},${l.length},${l.magEnd || 0}\n`;
    });

    // User POI
    csvContent += `[HEADER_POI],Id,x\n`;
    userPoi.forEach(p => {
        csvContent += `[USER_POI],${p.id},${p.x}\n`;
    });

    // Results Summary (For Record)
    csvContent += `[HEADER_RESULT],Section,Item,Value,Unit,LocationX\n`;
    
    // Section Properties
    csvContent += `[SECTION_PROPS],Label,"${sectionProps.label}",I(mm4),${sectionProps.I},Z(mm3),${sectionProps.Z},E(N/mm2),${sectionProps.E},A(cm2),${sectionProps.A},w(kg/m),${sectionProps.w}\n`;

    // ★[MODIFIED] Reactions
    results.reactions.forEach(r => {
        csvContent += `[RESULT_REACTION],${r.label},${r.val.toFixed(2)},kN,${r.x.toFixed(3)}\n`;
    });

    // ★[MODIFIED] Span-by-Span Bounds (Max/Min)
    if (results.spanBounds) {
        csvContent += `[HEADER_SPAN_BOUNDS],SpanIdx,Length,Item,Value,Unit,LocalX,GlobalX\n`;
        results.spanBounds.forEach(sb => {
            const offset = spans.slice(0, sb.spanIndex).reduce((a, b) => a + b, 0);
            const idx = sb.spanIndex + 1;
            const len = spans[sb.spanIndex];
            
            // Max M
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxM_Pos,${sb.maxM},kN.m,${(sb.maxM_x - offset).toFixed(3)},${sb.maxM_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxM_Neg,${sb.minM},kN.m,${(sb.minM_x - offset).toFixed(3)},${sb.minM_x}\n`;
            // Max Q
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxQ_Pos,${sb.maxQ},kN,${(sb.maxQ_x - offset).toFixed(3)},${sb.maxQ_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxQ_Neg,${sb.minQ},kN,${(sb.minQ_x - offset).toFixed(3)},${sb.minQ_x}\n`;
            // Max D
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxD_Pos,${sb.maxD},mm,${(sb.maxD_x - offset).toFixed(3)},${sb.maxD_x}\n`;
            csvContent += `[SPAN_BOUNDS],${idx},${len},MaxD_Neg,${sb.minD},mm,${(sb.minD_x - offset).toFixed(3)},${sb.minD_x}\n`;
        });
    }

    // ★[MODIFIED] Span-by-Span Detailed Results
    csvContent += `[HEADER_SPAN_DETAIL],SpanIdx,Type,LocalX(m),GlobalX(m),Q(kN),M(kN.m),Sigma(N/mm2),Deflection(mm)\n`;
    
    // Group points by span to output in order
    let currentX = 0;
    spans.forEach((len, sIdx) => {
        const rangeStart = currentX;
        const rangeEnd = currentX + len;
        
        // Find points in this span (inclusive of boundaries)
        const spanPoints = finalPoiData.filter(p => p.x >= rangeStart - 1e-4 && p.x <= rangeEnd + 1e-4);
        
        spanPoints.forEach(p => {
            const localX = Math.max(0, Math.min(len, p.x - rangeStart));
            // Force recalculation for this specific span index to handle discontinuities correctly
            const r = getResultAt(p.x, results, sectionProps, sIdx);
            
            csvContent += `[SPAN_DETAIL],${sIdx+1},${p.type},${localX.toFixed(3)},${p.x.toFixed(3)},${(r.Q||0).toFixed(3)},${(r.M||0).toFixed(3)},${(r.sigma||0).toFixed(2)},${(r.deflection||0).toFixed(3)}\n`;
        });
        
        currentX += len;
    });

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `structural_calc_result_${new Date().toISOString().slice(0,10)}.csv`;
    link.click();
    URL.revokeObjectURL(url);
  };

  // --- CSV Import Logic (v21.29 NEW) ---
  const importFromCSV = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    
    // Helper to parse CSV lines considering quotes (Fix for comma inside value)
    const parseCSVLine = (text) => {
        const result = [];
        let curr = '';
        let inQuote = false;
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            if (char === '"') {
                inQuote = !inQuote;
            } else if (char === ',' && !inQuote) {
                result.push(curr);
                curr = '';
            } else {
                curr += char;
            }
        }
        result.push(curr);
        return result.map(s => s.trim().replace(/^"|"$/g, '')); // 前後の空白と引用符を除去
    };

    reader.onload = (e) => {
        try {
            const text = e.target.result;
            const lines = text.split(/\r\n|\n/);
            
            const newLoads = [];
            const newUserPoi = [];
            let hasInput = false;
            
            lines.forEach(line => {
                // Ignore empty lines
                if (!line.trim()) return;
                
                const cols = parseCSVLine(line);
                if(cols.length < 2) return;
                const tag = cols[0];
                
                // Only process input tags
                if(tag === '[INPUT_BASIC]') {
                    hasInput = true;
                    // SpanStr,val,BeamType,val,MatType,val
                    setSpanStr(cols[2]);
                    setBeamType(cols[4]);
                    setMatType(cols[6]);
                } else if (tag === '[INPUT_STEEL]') {
                    setSteelShape(cols[2]);
                    setSteelProfileIdx(Number(cols[4]));
                    setSteelAxis(cols[6]);
                } else if (tag === '[INPUT_MANUAL]') {
                    setManualI(cols[2]);
                    setManualZ(cols[4]);
                    setManualA(cols[6]);
                    setManualE(cols[8]);
                } else if (tag === '[INPUT_RC]') {
                    setRcFcIdx(Number(cols[2]));
                    setRcWidthStr(cols[4]);
                    setRcDepthStr(cols[6]);
                } else if (tag === '[INPUT_PILE]') {
                    setEffI(cols[2]);
                    setEffZ(cols[4]);
                    setWallLength(cols[6]);
                } else if (tag === '[LOAD]') {
                    newLoads.push({
                        id: Number(cols[1]),
                        type: cols[2],
                        mag: Number(cols[3]),
                        pos: Number(cols[4]),
                        length: Number(cols[5]),
                        magEnd: Number(cols[6])
                    });
                } else if (tag === '[USER_POI]') {
                    newUserPoi.push({
                        id: Number(cols[1]),
                        x: Number(cols[2])
                    });
                }
            });
            
            if (hasInput) {
                setLoads(newLoads);
                setUserPoi(newUserPoi);
                setCalcError(null);
            } else {
                setCalcError("有効な入力データが見つかりませんでした。");
            }
        } catch (err) {
            console.error(err);
            setCalcError("ファイルの解析に失敗しました。正しいCSV形式ではありません。");
        }
    };
    reader.readAsText(file);
    event.target.value = '';
  };

  const addLoad = () => {
    const id = Date.now();
    let safePos = Math.max(0, Math.min(totalLength, Number(newPos)));
    let safeLength = Math.max(0, Number(newLength));
    if ((newLoadType === 'distributed' || newLoadType === 'trapezoid') && safePos + safeLength > totalLength) {
      safeLength = totalLength - safePos;
    }
    setLoads([...loads, {
      id, type: newLoadType, mag: Number(newMagStart), pos: safePos, length: safeLength,
      magEnd: newLoadType === 'trapezoid' ? Number(newMagEnd) : (newLoadType === 'distributed' ? Number(newMagStart) : 0)
    }]);
  };

  const handleTypeChange = (newType) => {
    setBeamType(newType);
    if(newType.includes('continuous3') && spanStr.indexOf(',')===-1) setSpanStr("5.0, 5.0, 5.0");
    else if(newType.includes('continuous2') && spanStr.indexOf(',')===-1) setSpanStr("5.0, 5.0");
    else if(newType.includes('overhang_one') && spanStr.indexOf(',')===-1) setSpanStr("6.0, 2.0");
    else if(newType.includes('overhang_both') && spanStr.indexOf(',')===-1) setSpanStr("2.0, 6.0, 2.0");
  };

  const handlePrint = () => {
      const reportHtml = renderToStaticMarkup(
          <PrintReport 
              params={{ 
                  spanStr, beamType, loads, matType, 
                  sectionProps, results, finalPoiData, 
                  spans, totalLength, supports 
              }} 
          />
      );

      const printWindow = window.open('', '_blank');
      if (!printWindow) {
          alert("ポップアップがブロックされました。ブラウザの設定で許可してください。");
          return;
      }

      const htmlContent = `
          <!DOCTYPE html>
          <html lang="ja">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>構造計算書 - 印刷プレビュー</title>
              <script src="https://cdn.tailwindcss.com"><\/script>
              <style>
                  body { font-family: 'Helvetica Neue', Arial, sans-serif; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
                  @page { size: A4 portrait; margin: 10mm; }
                  @media print {
                      .no-print { display: none; }
                      h2 { break-before: auto; }
                      .page-break { break-before: page; }
                      .avoid-break { page-break-inside: avoid; }
                  }
                  .container { max-width: 190mm; margin: 0 auto; background: white; padding: 5mm; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
                  @media screen {
                      body { background: #f1f5f9; padding: 20px; }
                  }
              </style>
          </head>
          <body>
              <div class="container">
                  ${reportHtml}
              </div>
              <script>
                  window.onload = () => {
                      setTimeout(() => {
                          window.print();
                      }, 800);
                  };
              <\/script>
          </body>
          </html>
      `;

      printWindow.document.write(htmlContent);
      printWindow.document.close();
  };

  return (
    <div className="min-h-screen bg-slate-50 font-sans text-slate-800">
      <div className="no-print p-4 md:p-8">
        <div className="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6">
            {/* Header */}
            <div className="lg:col-span-12 flex flex-col md:flex-row md:items-center justify-between gap-4">
            <div>
                <h1 className="text-3xl font-bold text-slate-900 flex items-center gap-3">
                <Activity className="w-8 h-8 text-blue-600" />
                構造計算アプリ Pro <span className="text-sm font-normal text-slate-500 bg-slate-200 px-2 py-1 rounded">v21.30</span>
                </h1>
                <p className="text-slate-500 text-sm mt-1">任意断面入力・モーメント荷重対応・不連続点自動補正</p>
            </div>
            
            <div className="flex items-center gap-2">
                <button onClick={() => setShowHistory(true)} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><History className="w-4 h-4 text-blue-500" />履歴</button>
                <button onClick={() => setShowHelp(true)} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><HelpCircle className="w-4 h-4 text-blue-500" />ヘルプ</button>
                <button onClick={() => setShowResultWindow(!showResultWindow)} className={`flex items-center gap-2 px-3 py-2 border border-slate-300 rounded-lg text-sm font-bold shadow-sm transition-all ${showResultWindow ? 'bg-blue-100 text-blue-700 border-blue-400' : 'bg-white text-slate-600 hover:bg-slate-50'}`}>
                <ExternalLink className="w-4 h-4" />別窓結果
                </button>
                <button onClick={handlePrint} className="flex items-center gap-2 px-3 py-2 bg-blue-600 border border-transparent rounded-lg text-sm font-bold text-white hover:bg-blue-700 shadow-sm transition-all"><Printer className="w-4 h-4" />印刷</button>
                
                {/* ★[MODIFIED] 結果出力(CSV)ボタン & 読込ボタンの変更 */}
                <button onClick={exportToCSV} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><FileDown className="w-4 h-4" />結果出力(CSV)</button>
                <button onClick={() => fileInputRef.current?.click()} className="flex items-center gap-2 px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm font-bold text-slate-600 hover:bg-slate-50 shadow-sm transition-all"><Upload className="w-4 h-4" />読込(CSV)</button>
                <input type="file" ref={fileInputRef} accept=".csv" onChange={importFromCSV} className="hidden" />
            </div>
            </div>

            {/* Help Modal Render */}
            {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
            {/* Version History Modal Render */}
            {showHistory && <VersionHistoryModal onClose={() => setShowHistory(false)} />}

            {/* Sidebar */}
            <div className="lg:col-span-4 space-y-6">
           
            <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2"><Settings className="w-5 h-5 text-slate-400" />モデル・荷重</h2>
                <div className="space-y-4 mb-6">
                <div>
                    <label className="text-xs font-bold text-slate-500 block mb-1">梁タイプ</label>
                    <select value={beamType} onChange={(e) => handleTypeChange(e.target.value)} className="w-full p-2 border border-slate-300 rounded text-sm">
                    {Object.entries(BEAM_TYPES).map(([key, val]) => <option key={key} value={key}>{val.label}</option>)}
                    </select>
                </div>
                <div>
                    <label className="text-xs font-bold text-slate-500 block mb-1">スパン長さ (m)</label>
                    <input type="text" value={spanStr} onChange={e=>setSpanStr(e.target.value)} className="w-full p-2 border rounded text-sm" placeholder="例: 6.0"/>
                    <p className="text-[10px] text-slate-400 mt-1">{BEAM_TYPES[beamType]?.hint || 'カンマ区切りで複数入力可'}</p>
                </div>
                </div>
                <div className="border-t pt-4">
                <h3 className="text-sm font-bold text-slate-600 mb-3">荷重追加</h3>
                {/* ★[MODIFIED] Added 'moment' to load types */}
                <div className="flex bg-slate-100 p-1 rounded mb-4">{['point', 'distributed', 'trapezoid', 'moment'].map(type => (<button key={type} onClick={() => setNewLoadType(type)} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${newLoadType === type ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>{type === 'point' ? '集中' : type === 'distributed' ? '等分布' : type === 'trapezoid' ? '台形' : 'モーメント'}</button>))}</div>
                <div className="space-y-3 mb-4">
                    <div className="flex gap-2">
                    <div className="w-1/2"><label className="text-xs text-slate-500 block">荷重{newLoadType!=='point' && newLoadType!=='moment' && '(始)'}</label><input type="number" value={newMagStart} onChange={e=>setNewMagStart(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    {newLoadType==='trapezoid' && <div className="w-1/2"><label className="text-xs text-slate-500 block">荷重(終)</label><input type="number" value={newMagEnd} onChange={e=>setNewMagEnd(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>}
                    </div>
                    <div className="flex gap-2">
                    <div className="w-1/2"><label className="text-xs text-slate-500 block">位置 x</label><input type="number" value={newPos} onChange={e=>setNewPos(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    {newLoadType!=='point' && newLoadType!=='moment' && <div className="w-1/2"><label className="text-xs text-slate-500 block">長さ L</label><input type="number" value={newLength} onChange={e=>setNewLength(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>}
                    </div>
                    {newLoadType === 'moment' && <p className="text-[10px] text-slate-400">※時計回りを正(+)として入力</p>}
                </div>
                <button onClick={addLoad} className="w-full py-2 bg-blue-600 text-white rounded text-sm font-bold hover:bg-blue-700 flex items-center justify-center gap-2"><Plus className="w-4 h-4"/> 荷重を追加</button>
                </div>
                <div className="mt-4 space-y-1 max-h-[150px] overflow-y-auto text-sm">
                {loads.map(l => (
                    <div key={l.id} className="flex justify-between items-center p-2 bg-slate-50 border rounded">
                    <div className="flex flex-col"><span className="font-bold text-slate-700">{l.type==='point' ? `P=${l.mag}kN` : l.type==='moment' ? `M=${l.mag}kN·m` : `w=${l.mag}kN/m`}</span><span className="text-xs text-slate-500">x={l.pos}m {l.type!=='point' && l.type!=='moment' && `(L=${l.length})`}</span></div>
                    <button onClick={()=>setLoads(loads.filter(x=>x.id!==l.id))}><Trash2 className="w-4 h-4 text-slate-300 hover:text-red-500"/></button>
                    </div>
                ))}
                </div>
            </div>

 <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2"><Layers className="w-5 h-5 text-slate-400" />断面・材料設定</h2>
                
                {/* ★[MODIFIED] Material Type Selector */}
                <div className="flex bg-slate-100 p-1 rounded-lg mb-4">
                    <button onClick={() => setMatType('steel')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'steel' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>S造</button>
                    <button onClick={() => setMatType('concrete')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'concrete' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>RC造</button>
                    <button onClick={() => setMatType('manual')} className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${matType === 'manual' ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>任意</button>
                </div>

                {matType === 'steel' && (
                <div className="space-y-4">
                      <div>
                        <label className="text-xs text-slate-500 font-bold block mb-1">鋼材種別</label>
                        <select value={steelShape} onChange={e => { setSteelShape(e.target.value); setSteelProfileIdx(0); }} className="w-full p-2 border rounded text-sm">
                            <option value="H">H形鋼</option>
                            <option value="Channel">溝形鋼</option>
                            <option value="LipChannel">C形鋼</option>
                            <option value="Angle">山形鋼</option>
                            <option value="SheetPile">鋼矢板 (U形)</option>
                            <option value="SheetPileW">鋼矢板 (広幅/w)</option>
                            <option value="SheetPileH">鋼矢板 (ハット形)</option>
                            <option value="LightSheetPile">軽量鋼矢板</option>
                            <option value="SquarePipe">角形鋼管 (Square Pipe)</option>
                        </select>
                    </div>
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">断面サイズ</label><select value={steelProfileIdx} onChange={e => setSteelProfileIdx(Number(e.target.value))} className="w-full p-2 border rounded text-sm font-mono">{STEEL_LISTS[steelShape].map((name, idx) => <option key={idx} value={idx}>{name}</option>)}</select></div>
                    {(!steelShape.includes('SheetPile') && !steelShape.includes('SquarePipe')) && (
                        <div className="flex bg-slate-50 border rounded p-1"><button onClick={() => setSteelAxis('strong')} className={`flex-1 text-xs py-1 rounded font-bold ${steelAxis === 'strong' ? 'bg-blue-100 text-blue-700' : 'text-slate-400'}`}>強軸 (X)</button><button onClick={() => setSteelAxis('weak')} className={`flex-1 text-xs py-1 rounded font-bold ${steelAxis === 'weak' ? 'bg-blue-100 text-blue-700' : 'text-slate-400'}`}>弱軸 (Y)</button></div>
                    )}
                    
                    {(steelShape.includes('SheetPile')) && (
                    <div className="mt-2 space-y-2 p-3 bg-yellow-50 rounded border border-yellow-200">
                        <div>
                            <label className="text-[10px] text-slate-500 font-bold block">施工延長 L (m) <span className="font-normal text-slate-400">(計算用壁幅)</span></label>
                            <input type="number" step="0.1" value={wallLength} onChange={e=>setWallLength(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right font-bold text-blue-600"/>
                        </div>
                        <div className="grid grid-cols-2 gap-3 pt-1 border-t border-yellow-200/50">
                            <div>
                                <label className="text-[10px] text-slate-500 font-bold block">効率 (I用)</label>
                                <input type="number" step="0.05" value={effI} onChange={e=>setEffI(e.target.value)} className="w-full p-1 border rounded text-xs bg-white text-right"/>
                            </div>
                            <div>
                                <label className="text-[10px] text-slate-500 font-bold block">効率 (Z用)</label>
                                <input type="number" step="0.05" value={effZ} onChange={e=>setEffZ(e.target.value)} className="w-full p-1 border rounded text-xs bg-white text-right"/>
                            </div>
                        </div>
                    </div>
                    )}
                </div>
                )}
                
                {matType === 'concrete' && (
                <div className="space-y-4">
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">コンクリート</label><select value={rcFcIdx} onChange={e => setRcFcIdx(Number(e.target.value))} className="w-full p-2 border rounded text-sm">{CONCRETE_STRENGTHS.map((fc, idx) => <option key={idx} value={idx}>{fc.label}</option>)}</select></div>
                    <div className="grid grid-cols-2 gap-3">
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">幅 b</label><input type="number" value={rcWidthStr} onChange={e=>setRcWidthStr(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    <div><label className="text-xs text-slate-500 font-bold block mb-1">高さ D</label><input type="number" value={rcDepthStr} onChange={e=>setRcDepthStr(e.target.value)} className="w-full p-2 border rounded text-sm"/></div>
                    </div>
                </div>
                )}

                {/* ★[MODIFIED] Manual Input UI */}
                {matType === 'manual' && (
                <div className="space-y-3 bg-blue-50 p-4 rounded border border-blue-100">
                      <p className="text-xs text-slate-500 mb-2 font-bold text-center border-b border-blue-200 pb-2">任意断面入力</p>
                      <div>
                        <label className="text-[10px] text-slate-500 font-bold block">断面二次モーメント Ix (cm⁴)</label>
                        <input type="number" step="1" value={manualI} onChange={e=>setManualI(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                    <div>
                        <label className="text-[10px] text-slate-500 font-bold block">断面係数 Zx (cm³)</label>
                        <input type="number" step="1" value={manualZ} onChange={e=>setManualZ(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                      <div>
                        <label className="text-[10px] text-slate-500 font-bold block">ヤング係数 E (kN/mm²)</label>
                        <input type="number" step="1" value={manualE} onChange={e=>setManualE(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                      <div>
                        <label className="text-[10px] text-slate-500 font-bold block">断面積 A (cm²) <span className="font-normal text-slate-400">(重量計算用)</span></label>
                        <input type="number" step="0.1" value={manualA} onChange={e=>setManualA(e.target.value)} className="w-full p-1.5 border rounded text-sm bg-white text-right"/>
                    </div>
                </div>
                )}

                <div className="mt-4 grid grid-cols-2 gap-4">
                <div className="p-3 bg-slate-50 rounded border text-xs space-y-1 font-mono text-slate-600">
                    <div className="flex justify-between"><span>Ix:</span> <span>{(sectionProps.I/10000).toFixed(3)} cm⁴</span></div>
                    <div className="flex justify-between"><span>Zx:</span> <span>{(sectionProps.Z/1000).toFixed(3)} cm³</span></div>
                    <div className="flex justify-between"><span>E :</span> <span>{(sectionProps.E/1000).toFixed(1)} kN/mm²</span></div>
                    <div className="flex justify-between text-slate-500 mt-1 border-t pt-1"><span>A :</span> <span>{sectionProps.A.toFixed(2)} cm²</span></div>
                    <div className="flex justify-between text-slate-500"><span>w :</span> <span>{sectionProps.w.toFixed(1)} kg/m</span></div>
                </div>
                <div className="flex items-center justify-center bg-white border rounded aspect-square p-2"><SectionProfileView props={sectionProps} /></div>
                </div>
            </div>

            </div>

            {/* Main Content */}
            <div className="lg:col-span-8 space-y-6">
            <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                <ResultBox label="最大M (+)" val={results.bounds.maxM_pos} x={results.bounds.maxM_pos_x} unit="kN·m" color="text-emerald-600" sub={`σ=${results.bounds.maxSigma_pos.toFixed(0)}`} />
                <ResultBox label="最大M (-)" val={results.bounds.maxM_neg} x={results.bounds.maxM_neg_x} unit="kN·m" color="text-red-600" sub={`σ=${Math.abs(results.bounds.maxSigma_neg).toFixed(0)}`} />
                <ResultBox label="最大たわみ" val={results.bounds.maxDeflection} x={results.bounds.maxDef_x} unit="mm" color="text-blue-600" />
                <ResultBox label="最大せん断" val={results.bounds.maxShear} x={results.bounds.maxShear_x} unit="kN" color="text-amber-600" />
                {results.reactions.map((r, i) => (
                <ResultBox key={i} label={`反力 ${r.label}`} val={r.val} unit="kN" color="text-purple-600" sub={`@${r.x.toFixed(1)}m`} />
                ))}
            </div>
            
            {calcError ? (
                <div className="bg-red-50 border-red-200 border p-4 text-red-700 rounded flex items-center gap-2"><AlertTriangle className="w-5 h-5"/>{calcError}</div>
            ) : (
                <>
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6 overflow-hidden">
                    <h2 className="text-sm font-bold text-slate-500 mb-4 flex items-center justify-between">
                    <span>解析結果グラフ ({sectionProps.label})</span>
                    <span className="text-xs font-normal bg-slate-100 px-2 py-1 rounded text-slate-500">モデル全長: {totalLength.toFixed(2)}m</span>
                    </h2>
                    <AdvancedVisualizer spans={spans} supports={supports} totalLength={totalLength} loads={loads} results={results} />
                </div>
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                    <PoiTable 
                        finalPoiData={finalPoiData} 
                        userPoi={userPoi} 
                        setUserPoi={setUserPoi} 
                        totalLength={totalLength} 
                        spans={spans} 
                        results={results}
                        sectionProps={sectionProps}
                    />
                </div>
                </>
            )}
            </div>
        </div>
      </div> 

　　　　{showResultWindow && (
        <ResultWindow onClose={() => setShowResultWindow(false)}>
            <ResultContent 
                results={results}
                sectionProps={sectionProps}
                loads={loads}
                spans={spans}
                supports={supports}
                totalLength={totalLength}
                finalPoiData={finalPoiData}
                userPoi={userPoi}
                setUserPoi={setUserPoi}
            />
        </ResultWindow>
      )}
      
    </div>
  );
}

// ==========================================
// [PRINT COMPONENT] 印刷用レイアウト
// ==========================================
function PrintReport({ params }) {
    const { sectionProps, results, loads, spans, totalLength, beamType, finalPoiData } = params;
    const today = new Date().toLocaleDateString('ja-JP');

    const spanRanges = spans.map((len, idx) => {
        const start = spans.slice(0, idx).reduce((a, b) => a + b, 0);
        return { idx, len, start, end: start + len };
    });

    return (
        <div className="space-y-6 text-sm text-slate-800">
            <header className="border-b-2 border-slate-800 pb-2 mb-4 flex justify-between items-end">
                <div>
                    <h1 className="text-xl font-bold text-slate-900">構造計算書</h1>
                    <p className="text-xs text-slate-500">Structural Analysis Report</p>
                </div>
                <div className="text-right">
                    <p className="font-bold text-sm">作成日: {today}</p>
                    <p className="text-xs text-slate-500">Ver 21.29</p>
                </div>
            </header>

            <div className="grid grid-cols-2 gap-6 mb-4 avoid-break">
                <section>
                    <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">1. 設計条件</h2>
                    <table className="w-full text-left text-xs border-collapse">
                        <tbody>
                            <tr className="border-b"><th className="py-1 text-slate-500 w-24">梁タイプ</th><td className="font-bold">{BEAM_TYPES[beamType]?.label}</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">スパン構成</th><td className="font-mono">{spans.map(s=>s.toFixed(2)+'m').join(' + ')} (L={totalLength.toFixed(2)}m)</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">使用材料</th><td className="font-bold">{sectionProps.label}</td></tr>
                            <tr className="border-b"><th className="py-1 text-slate-500">断面性能</th><td className="font-mono">
                                I={(sectionProps.I/10000).toFixed(3)}cm⁴, Z={(sectionProps.Z/1000).toFixed(3)}cm³, E={(sectionProps.E/1000).toFixed(1)}kN/mm²
                            </td></tr>
                        </tbody>
                    </table>
                </section>
                
                <section>
                    <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">2. 荷重条件</h2>
                    <table className="w-full text-xs text-left border border-slate-200">
                        <thead className="bg-slate-100">
                            <tr><th className="p-1 border">No.</th><th className="p-1 border">種類</th><th className="p-1 border">大きさ</th><th className="p-1 border">位置</th></tr>
                        </thead>
                        <tbody>
                            {loads.map((l, i) => (
                                <tr key={l.id} className="border-b">
                                    <td className="p-1 border text-center">{i+1}</td>
                                    <td className="p-1 border">{l.type === 'point' ? '集中' : l.type === 'moment' ? 'モーメント' : '分布'}</td>
                                    <td className="p-1 border font-mono">{l.type==='trapezoid'?`${l.mag}~${l.magEnd}`:l.mag}</td>
                                    <td className="p-1 border font-mono">{l.type==='point'||l.type==='moment'?l.pos:`${l.pos}~${l.pos+l.length}`}</td>
                                </tr>
                            ))}
                            {loads.length===0 && <tr><td colSpan="4" className="p-2 text-center text-slate-400">なし</td></tr>}
                        </tbody>
                    </table>
                </section>
            </div>

            <section className="mb-4">
                <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">3. 解析結果一覧（スパン別最大・最小）</h2>
                <div className="grid grid-cols-1 gap-4">
                    {results.spanBounds.map((sb, idx) => {
                        const offset = spans.slice(0, idx).reduce((a, b) => a + b, 0);
                        return (
                            <div key={idx} className="avoid-break border rounded-lg overflow-hidden mb-2">
                                <div className="text-xs font-bold bg-slate-100 px-2 py-1 border-b text-slate-700">
                                    径間 {idx + 1} <span className="font-normal ml-2 text-slate-500">L = {spans[idx].toFixed(2)}m</span>
                                </div>
                                <table className="w-full text-xs text-right">
                                    <thead className="bg-slate-50 text-slate-600">
                                            <tr>
                                                <th className="p-1 border-b w-32 text-left pl-2">項目</th>
                                                <th className="p-1 border-b">値</th>
                                                <th className="p-1 border-b">位置 x (local)</th>
                                                <th className="p-1 border-b">応力度 σ (N/mm²)</th>
                                            </tr>
                                    </thead>
                                    <tbody>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大曲げ M<sub>max</sub> (+)</td>
                                                <td className="p-1 font-mono font-bold">{sb.maxM.toFixed(2)} kN·m</td>
                                                <td className="p-1 font-mono">{(sb.maxM_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 font-mono">{(Math.abs(sb.maxM) * 1e6 / sectionProps.Z).toFixed(0)}</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大曲げ M<sub>min</sub> (-)</td>
                                                <td className="p-1 font-mono font-bold">{sb.minM.toFixed(2)} kN·m</td>
                                                <td className="p-1 font-mono">{(sb.minM_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 font-mono">{(Math.abs(sb.minM) * 1e6 / sectionProps.Z).toFixed(0)}</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大せん断 Q<sub>max</sub> (+)</td>
                                                <td className="p-1 font-mono font-bold">{sb.maxQ.toFixed(2)} kN</td>
                                                <td className="p-1 font-mono">{(sb.maxQ_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大せん断 Q<sub>min</sub> (-)</td>
                                                <td className="p-1 font-mono font-bold">{sb.minQ.toFixed(2)} kN</td>
                                                <td className="p-1 font-mono">{(sb.minQ_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                            <tr className="border-b">
                                                <td className="p-1 text-left pl-2">最大変位 δ<sub>max</sub> (+)</td>
                                                <td className="p-1 font-mono font-bold">{sb.maxD.toFixed(2)} mm</td>
                                                <td className="p-1 font-mono">{(sb.maxD_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                             <tr>
                                                <td className="p-1 text-left pl-2">最大変位 δ<sub>min</sub> (-)</td>
                                                <td className="p-1 font-mono font-bold">{sb.minD.toFixed(2)} mm</td>
                                                <td className="p-1 font-mono">{(sb.minD_x - offset).toFixed(3)} m</td>
                                                <td className="p-1 text-slate-400">-</td>
                                            </tr>
                                    </tbody>
                                </table>
                            </div>
                        );
                    })}
                    
                    <div className="avoid-break mt-2 border rounded p-2 bg-slate-50">
                         <div className="text-xs font-bold text-slate-600 mb-1">支点反力一覧</div>
                         <div className="flex flex-wrap gap-4">
                            {results.reactions.map((r, i) => (
                                <div key={i} className="text-xs font-mono">
                                    R<sub>{r.label}</sub> = <strong>{r.val.toFixed(2)}</strong> kN <span className="text-slate-400">(@{r.x.toFixed(1)}m)</span>
                                </div>
                            ))}
                         </div>
                    </div>
                </div>
            </section>

            <section className="mb-4 avoid-break">
                <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">4. 応力図 (SFD, BMD, Deflection)</h2>
                <div className="border rounded p-2 flex justify-center bg-white">
                    <AdvancedVisualizer {...params} forceWidth={580} />
                </div>
            </section>

            <section className="page-break"　>
                <h2 className="text-sm font-bold border-l-4 border-blue-600 pl-2 mb-2 bg-slate-50 py-1">5. 計算結果詳細（スパン別）</h2>
                <div className="grid grid-cols-1 gap-4">
                    {spanRanges.map((range, sIdx) => {
                        const spanPoints = finalPoiData.filter(p => p.x >= range.start - 1e-4 && p.x <= range.end + 1e-4);
                        if (spanPoints.length === 0) return null;

                        return (
                            <div key={sIdx} className="avoid-break mb-2">
                                <div className="text-xs font-bold bg-slate-100 px-2 py-1 border-t border-l border-r rounded-t text-slate-700">
                                    径間 {sIdx + 1} ({String.fromCharCode(65+sIdx)} - {String.fromCharCode(65+sIdx+1)}) 
                                    <span className="font-normal ml-2 text-slate-500">L = {range.len.toFixed(2)}m</span>
                                </div>
                                <table className="w-full text-xs text-right border border-slate-200">
                                    <thead className="bg-slate-50 text-slate-600">
                                            <tr>
                                                <th className="p-1 border w-16 text-center">x (local)</th>
                                                <th className="p-1 border">せん断 Q (kN)</th>
                                                <th className="p-1 border">曲げ M (kN·m)</th>
                                                <th className="p-1 border">応力 σ (N/mm²)</th>
                                                <th className="p-1 border">たわみ δ (mm)</th>
                                            </tr>
                                    </thead>
                                    <tbody>
                                            {spanPoints.map((p, idx) => {
                                                const localX = Math.max(0, Math.min(range.len, p.x - range.start));
                                                
                                                // ★[MODIFIED] Force span index to get isolated span results
                                                const val = getResultAt(p.x, results, sectionProps, sIdx);

                                                return (
                                                    <tr key={idx} className="border-b">
                                                        <td className="p-1 border text-center font-mono bg-slate-50/50">{localX.toFixed(3)}</td>
                                                        <td className="p-1 border font-mono">{val?.Q?.toFixed(2)}</td>
                                                        <td className="p-1 border font-mono">{val?.M?.toFixed(2)}</td>
                                                        <td className="p-1 border font-mono">{val?.sigma?.toFixed(1)}</td>
                                                        <td className="p-1 border font-mono">{val?.deflection?.toFixed(2)}</td>
                                                    </tr>
                                                );
                                            })}
                                    </tbody>
                                </table>
                            </div>
                        );
                    })}
                </div>
            </section>
        </div>
    );
}

// ==========================================
// [CORE ENGINE] Universal Beam Solver
// ==========================================

function solveGeneralBeam(spans, supports, loads, resolution, props) {
  const totalL = spans.reduce((a, b) => a + b, 0);
  const validSupportIndices = supports.map((s, i) => s !== 'free' ? i : -1).filter(i => i !== -1);
  if (validSupportIndices.length < 1) return generateEmptyResult();

  const idxStart = validSupportIndices[0];
  const idxEnd = validSupportIndices[validSupportIndices.length - 1];

  const spanLoads = spans.map(() => []);
  let cx = 0;
  spans.forEach((len, i) => {
    const sx = cx; const ex = cx + len;
    loads.forEach(l => {
      // ----------------------------------------------------------------
      // ★[MODIFIED] 固定端(Fixed)上の集中モーメント荷重を計算から除外 (v21.18)
      // ----------------------------------------------------------------
      // 左端固定の場合: 座標0 かつ 支点0がfixed
      if (l.type === 'moment' && l.pos === 0 && supports[0] === 'fixed') {
          return; 
      }
      // 右端固定の場合: 座標totalL かつ 最終支点がfixed
      if (l.type === 'moment' && l.pos === totalL && supports[supports.length - 1] === 'fixed') {
          return;
      }
      // ----------------------------------------------------------------

      const lStart = l.pos;
      const lEnd = l.type === 'point' || l.type === 'moment' ? l.pos : l.pos + l.length;
      const oStart = Math.max(sx, lStart);
      const oEnd = Math.min(ex, lEnd);
      if ((oEnd > oStart + EPS) || ((l.type === 'point' || l.type === 'moment') && lStart >= sx - EPS && (i === spans.length-1 ? lStart <= ex + EPS : lStart < ex - EPS))) {
        let mag = l.mag; let magEnd = l.magEnd;
        if (l.type === 'trapezoid') {
           const slope = (l.magEnd - l.mag) / l.length;
           mag = l.mag + slope * (oStart - l.pos);
           magEnd = l.mag + slope * (oEnd - l.pos);
        }
        spanLoads[i].push({ ...l, pos: oStart - sx, length: oEnd - oStart, mag, magEnd });
      }
    });
    cx += len;
  });

  let M_start = 0; 
  if (idxStart > 0) {
    for (let i = 0; i < idxStart; i++) {
       const distToSupport = spans.slice(i+1, idxStart).reduce((a,b)=>a+b, 0);
       spanLoads[i].forEach(l => {
         if (l.type === 'moment') {
             M_start += l.mag;
         } else {
             const { totalForce, momentA } = getLoadIntegral(l);
             const xc = totalForce !== 0 ? momentA / totalForce : 0;
             const arm = (spans[i] - xc) + distToSupport;
             M_start -= totalForce * arm; 
         }
       });
    }
  }
  let M_end = 0;
  if (idxEnd < spans.length) {
    for (let i = idxEnd; i < spans.length; i++) {
       const distToSupport = spans.slice(idxEnd, i).reduce((a,b)=>a+b, 0);
       spanLoads[i].forEach(l => {
         if (l.type === 'moment') {
             M_end -= l.mag; 
         } else {
             const { totalForce, momentA } = getLoadIntegral(l);
             const xc = totalForce !== 0 ? momentA / totalForce : 0;
             const arm = distToSupport + xc;
             M_end -= totalForce * arm;
         }
       });
    }
  }

  const numNodes = idxEnd - idxStart + 1;
  const nodeMoments = new Array(spans.length + 1).fill(0);
  
  if (numNodes <= 1) {
    if (idxStart === idxEnd) nodeMoments[idxStart] = M_start + M_end;
  } else {
    const matrixSize = numNodes;
    const A = Array.from({ length: matrixSize }, () => Array(matrixSize).fill(0));
    const B = Array(matrixSize).fill(0);

    for (let k = 0; k < numNodes; k++) {
      const nodeIdx = idxStart + k;
      const supportType = supports[nodeIdx]; 
      const leftSpanIdx = nodeIdx - 1;
      const rightSpanIdx = nodeIdx;
      // ★[MODIFIED] High Precision CalcPhi
      const phiL_load = (leftSpanIdx >= idxStart) ? calcPhi(spans[leftSpanIdx], spanLoads[leftSpanIdx]).phiR : 0;
      const phiR_load = (rightSpanIdx < idxEnd) ? calcPhi(spans[rightSpanIdx], spanLoads[rightSpanIdx]).phiL : 0;

      if (k === 0) {
        if (supportType === 'fixed') {
          A[k][k] = 2 * spans[rightSpanIdx];
          if (numNodes > 1) A[k][k+1] = spans[rightSpanIdx];
          B[k] = -6 * phiR_load;
        } else {
          A[k][k] = 1; B[k] = M_start;
        }
      } else if (k === numNodes - 1) {
        if (supportType === 'fixed') {
          const len = spans[leftSpanIdx];
          A[k][k-1] = len; A[k][k] = 2 * len;
          B[k] = -6 * phiL_load;
        } else {
          A[k][k] = 1; B[k] = M_end;
        }
      } else {
        A[k][k-1] = spans[leftSpanIdx];
        A[k][k] = 2 * (spans[leftSpanIdx] + spans[rightSpanIdx]);
        A[k][k+1] = spans[rightSpanIdx];
        B[k] = -6 * (phiL_load + phiR_load);
      }
    }
    const M_solutions = solveLinearSystem(A, B);
    for(let k=0; k<numNodes; k++) {
      nodeMoments[idxStart + k] = M_solutions[k];
    }
  }

  const shearData = []; 
  const momentData = [];
  let globalX = 0;

  for (let i = 0; i < spans.length; i++) {
    const len = spans[i];
    const sLoads = spanLoads[i];
    const ML = nodeMoments[i];
    const MR = nodeMoments[i+1];

    const keyPoints = new Set([0, len]);
    sLoads.forEach(l => { 
        keyPoints.add(l.pos); 
        if (l.type === 'moment') {
            keyPoints.add(Math.max(0, l.pos - 1e-6));
            keyPoints.add(Math.min(len, l.pos + 1e-6));
        } else if(l.type !== 'point') {
            keyPoints.add(l.pos + l.length);
        }
    });
    
    // ★[MODIFIED] Graph generation pitch 5mm (200 steps/m) optimized for SVG
    // Limit total points per span to avoid rendering lag
    const steps = Math.max(50, Math.min(Math.ceil(len * 200), 2000));
    for(let k=0; k<=steps; k++) keyPoints.add(k * (len / steps));
    const sortedLx = Array.from(keyPoints).sort((a,b)=>a-b);

    let sumP=0, sumM=0;
    sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
    const Rb_s = sumM/len; const Ra_s = sumP - Rb_s;

    sortedLx.forEach(lx => {
        const gx = globalX + lx;
        const Qb = (MR - ML) / len;
        
        const Q_left = getSectionForceSimple(lx, sLoads, Ra_s, 'left').Q + Qb;
        const Q_right = getSectionForceSimple(lx, sLoads, Ra_s, 'right').Q + Qb;
        
        shearData.push({ x: gx, y: Q_left });
        if (Math.abs(Q_left - Q_right) > 1e-6) {
            shearData.push({ x: gx, y: Q_right });
        }
        
        const Ms = getSectionForceSimple(lx, sLoads, Ra_s).M;
        const Mb = ML + (MR - ML) * (lx / len);
        momentData.push({ x: gx, y: Ms + Mb });
    });
    globalX += len;
  }

  const deflectionData = [];
  const rawIntegration = [];
  let curTh = 0, curY = 0;
  rawIntegration.push({ x: 0, th: 0, y: 0 });

  for (let j = 0; j < momentData.length - 1; j++) {
      const p1 = momentData[j], p2 = momentData[j+1];
      const dx = p2.x - p1.x;
      if (dx < 1e-8) continue;
      
      const phi1 = -(p1.y * 1e6) / (props.E * props.I);
      const phi2 = -(p2.y * 1e6) / (props.E * props.I);
      const dTh = (phi1 + phi2) * 0.5 * dx * 1000;
      const dY = (curTh + (curTh + dTh)) * 0.5 * dx * 1000;
      curTh += dTh; curY += dY;
      rawIntegration.push({ x: p2.x, th: curTh, y: curY });
  }

  let C1 = 0, C2 = 0;
  const getRaw = (x) => {
      const match = rawIntegration.find(p => Math.abs(p.x - x) < 1e-4);
      if (match) return match;
      const low = rawIntegration.filter(p => p.x <= x).pop();
      const high = rawIntegration.find(p => p.x > x);
      if (!low || !high) return low || high || { th: 0, y: 0 };
      const r = (x - low.x) / (high.x - low.x);
      return { th: low.th + (high.th - low.th) * r, y: low.y + (high.y - low.y) * r };
  };

  const supportPoints = [];
  let tx = 0;
  supports.forEach((s, i) => {
      if (s !== 'free') supportPoints.push({ x: tx, type: s });
      if (i < spans.length) tx += spans[i];
  });

  if (supportPoints.length > 0) {
      const firstS = supportPoints[0];
      if (firstS.type === 'fixed') {
          const raw = getRaw(firstS.x);
          C1 = -raw.th;
          C2 = -raw.y - C1 * firstS.x;
      } else if (supportPoints.length >= 2) {
          const s1 = supportPoints[0], s2 = supportPoints[supportPoints.length - 1];
          const r1 = getRaw(s1.x), r2 = getRaw(s2.x);
          C1 = -(r2.y - r1.y) / (s2.x - s1.x);
          C2 = -r1.y - C1 * s1.x;
      } else {
          const r1 = getRaw(firstS.x);
          C1 = 0; C2 = -r1.y;
      }
  }

  rawIntegration.forEach(p => {
      deflectionData.push({ x: p.x, y: p.y + C1 * p.x + C2 });
  });

  const spanBounds = [];
  let sx = 0;
  for (let i = 0; i < spans.length; i++) {
    const ex = sx + spans[i];
    
    const sLoads = spanLoads[i];
    let sumP=0, sumM=0;
    sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
    const len = spans[i];
    const Rb_s = sumM/len; const Ra_s = sumP - Rb_s;
    const ML = nodeMoments[i]; const MR = nodeMoments[i+1];
    const Qb = (MR - ML) / len;

    const zeroCrossX = [];
    const checkStep = 50; 
    for(let k=0; k<checkStep; k++) {
        const x1 = (k/checkStep)*len;
        const x2 = ((k+1)/checkStep)*len;
        const Q1 = getSectionForceSimple(x1, sLoads, Ra_s).Q + Qb;
        const Q2 = getSectionForceSimple(x2, sLoads, Ra_s).Q + Qb;
        if(Q1 * Q2 < 0) {
             const x0 = x1 + (0 - Q1) * (x2 - x1) / (Q2 - Q1);
             zeroCrossX.push(x0);
        }
    }

    const sM_points = momentData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    const sQ_points = shearData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);
    const sD_points = deflectionData.filter(d => d.x >= sx - EPS && d.x <= ex + EPS);

    zeroCrossX.forEach(zx => {
        const gx = sx + zx;
        const res = getSectionForceSimple(zx, sLoads, Ra_s);
        const Mb = ML + (MR - ML) * (zx / len);
        const valM = res.M + Mb;
        sM_points.push({ x: gx, y: valM });
    });

    const maxM = Math.max(...sM_points.map(d => d.y)), minM = Math.min(...sM_points.map(d => d.y));
    const maxQ = Math.max(...sQ_points.map(d => d.y)), minQ = Math.min(...sQ_points.map(d => d.y));
    const maxD = Math.max(...sD_points.map(d => d.y)), minD = Math.min(...sD_points.map(d => d.y));

    spanBounds.push({
      spanIndex: i, 
      maxM, maxM_x: sM_points.find(d => d.y === maxM)?.x || sx,
      minM, minM_x: sM_points.find(d => d.y === minM)?.x || sx,
      maxQ, maxQ_x: sQ_points.find(d => d.y === maxQ)?.x || sx,
      minQ, minQ_x: sQ_points.find(d => d.y === minQ)?.x || sx,
      maxD, maxD_x: sD_points.find(d => d.y === maxD)?.x || sx,
      minD, minD_x: sD_points.find(d => d.y === minD)?.x || sx
    });
    sx = ex;
  }

  const reactions = [];
  validSupportIndices.forEach(idx => {
    let pos = 0; for(let k=0; k<idx; k++) pos += spans[k];
    let R_val = 0;

    if (idx > 0) {
        const i = idx - 1;
        const len = spans[i];
        const sLoads = spanLoads[i];
        let sumP=0, sumM=0;
        sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
        const Rb_simple = sumM/len; 
        
        const ML = nodeMoments[i]; const MR = nodeMoments[i+1];
        const Q_mom = (MR - ML) / len; 
        R_val += (Rb_simple - Q_mom);
    }

    if (idx < spans.length) {
        const i = idx;
        const len = spans[i];
        const sLoads = spanLoads[i];
        let sumP=0, sumM=0;
        sLoads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
        const Rb_simple = sumM/len;
        const Ra_simple = sumP - Rb_simple;

        const ML = nodeMoments[i]; const MR = nodeMoments[i+1];
        const Q_mom = (MR - ML) / len;
        
        R_val += (Ra_simple + Q_mom);
    }
    
    reactions.push({ x: pos, val: R_val, label: String.fromCharCode(65+idx) });
  });

  const maxM_pos = Math.max(0, ...momentData.map(d=>d.y));
  const maxM_neg = Math.min(0, ...momentData.map(d=>d.y));

  return {
    shearData, momentData, deflectionData, spanBounds, reactions,
    // ★[MODIFIED] Added Raw Data for Exact Analytical Calculation
    raw: { spans, spanLoads, nodeMoments, supports },
    bounds: { 
      maxShear: Math.max(...shearData.map(d=>Math.abs(d.y))), maxShear_x: 0,
      maxM_pos, maxM_pos_x: momentData.find(d=>d.y===maxM_pos)?.x || 0,
      maxM_neg, maxM_neg_x: momentData.find(d=>d.y===maxM_neg)?.x || 0,
      maxDeflection: Math.max(...deflectionData.map(d=>Math.abs(d.y))), 
      maxDef_x: deflectionData.find(d=>Math.abs(d.y) === Math.max(...deflectionData.map(v=>Math.abs(v.y))))?.x || 0,
      maxSigma_pos: maxM_pos * 1e6 / props.Z,
      maxSigma_neg: maxM_neg * 1e6 / props.Z
    },
  };
}

// ★[MODIFIED] Result Retrieval Logic (Exact Analysis & Support Correction)
function getResultAt(x, results, props, targetSpanIndex = -1) {
    if (!results.momentData) return {};

    // 1. Analytical Calculation for Forces (Q, M, Sigma)
    if (results.raw) {
        const { spans, spanLoads, nodeMoments, supports } = results.raw;
        let currentX = 0;
        let spanIndex = -1;
        let localX = 0;

        // ★[MODIFIED] Span enforcement logic
        if (targetSpanIndex !== -1 && targetSpanIndex >= 0 && targetSpanIndex < spans.length) {
            for(let k=0; k<targetSpanIndex; k++) currentX += spans[k];
            spanIndex = targetSpanIndex;
            localX = x - currentX;
            // Force localX to be within bounds (handle precision errors)
            if(localX < 0 && localX > -0.001) localX = 0;
            if(localX > spans[spanIndex] && localX < spans[spanIndex] + 0.001) localX = spans[spanIndex];
        } else {
            // Auto detection (fallback)
            for(let i=0; i<spans.length; i++) {
                if (x >= currentX - 1e-9 && x <= currentX + spans[i] + 1e-9) {
                    spanIndex = i;
                    localX = x - currentX;
                    if(localX < 0) localX = 0;
                    if(localX > spans[i]) localX = spans[i];
                    break;
                }
                currentX += spans[i];
            }
        }

        if (spanIndex !== -1) {
            const len = spans[spanIndex];
            const loads = spanLoads[spanIndex];
            const ML = nodeMoments[spanIndex];
            const MR = nodeMoments[spanIndex + 1];

            // Simple Beam Reaction for this span
            let sumP=0, sumM=0;
            loads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
            const Rb_simple = sumM/len;
            const Ra_simple = sumP - Rb_simple;

            // Superposition
            // ★[MODIFIED] Use side='right' to include point loads/moments at the exact location
            const simpleRes = getSectionForceSimple(localX, loads, Ra_simple, 'right');
            const Qb = (MR - ML) / len;
            const Mb = ML + (MR - ML) * (localX / len);
            
            const totalQ = simpleRes.Q + Qb;
            let totalM = simpleRes.M + Mb;

            // ★[PATCH] 右端における集中モーメント荷重の補正 (v21.17 Modified)
            // 右端がフリーまたは単純支持(pin/roller)のときで右端に集中モーメントが作用するときに、結果表の右端のモーメント表示を補正する
            // (ユーザー指示により、このブロックは維持する)
            const totalLen = spans.reduce((a,b)=>a+b, 0);
            const rightSupport = supports[supports.length - 1];
            
            // 対象となる支持条件: free, pin, roller (右端単純支持も含む)
            const isTargetSupport = ['free', 'pin', 'roller'].includes(rightSupport);

            if (Math.abs(x - totalLen) < 0.001 && isTargetSupport) {
                const lastSpanIdx = spans.length - 1;
                const lastSpanLoads = spanLoads[lastSpanIdx];
                const lastSpanLen = spans[lastSpanIdx];
                
                let endMomentSum = 0;
                lastSpanLoads.forEach(l => {
                    // ローカル座標でスパン終端にあるモーメント荷重を探す
                    if (l.type === 'moment' && Math.abs(l.pos - lastSpanLen) < 0.001) {
                        endMomentSum += l.mag;
                    }
                });
                
                // 右端に作用する集中モーメントの合計の逆の符号を加算
                if (endMomentSum !== 0) {
                    totalM += (-endMomentSum);
                }
            }

            // 2. Deflection (Graph Interpolation + Support Zero Correction)
            let defVal = 0;
            if (results.deflectionData) {
                 const arr = results.deflectionData;
                 const match = arr.find(p => Math.abs(p.x - x) < 1e-4);
                 if (match) defVal = match.y;
                 else {
                     const low = arr.filter(p => p.x <= x).pop();
                     const high = arr.find(p => p.x > x);
                     if (low && high) {
                         defVal = low.y + (high.y - low.y) * ((x - low.x)/(high.x - low.x));
                     } else {
                         defVal = low ? low.y : (high ? high.y : 0);
                     }
                 }
            }

            // Force Zero Deflection at Supports (±1mm tolerance)
            let supX = 0;
            let isNearSupport = false;
            for(let i=0; i<supports.length; i++) {
                if (supports[i] !== 'free') {
                    if (Math.abs(x - supX) < 0.001) {
                        isNearSupport = true;
                        break;
                    }
                }
                if (i < spans.length) supX += spans[i];
            }
            if (isNearSupport) defVal = 0;

            return {
                Q: totalQ,
                M: totalM,
                deflection: defVal,
                sigma: Math.abs(totalM * 1e6 / props.Z)
            };
        }
    }

    // Fallback logic (Graph Lookup)
    const getVal = (arr) => {
        if (!arr || arr.length === 0) return 0;
        const match = arr.find(p => Math.abs(p.x - x) < 1e-4);
        if (match) return match.y;
        const low = arr.filter(p => p.x <= x).pop();
        const high = arr.find(p => p.x > x);
        if (low && high) {
             return low.y + (high.y - low.y) * ((x - low.x)/(high.x - low.x));
        }
        return low ? low.y : (high ? high.y : 0);
    };
    const M = getVal(results.momentData);
    return {
        Q: getVal(results.shearData),
        M: M,
        deflection: getVal(results.deflectionData),
        sigma: Math.abs(M * 1e6 / props.Z)
    };
}

function getSectionForceSimple(x, loads, Ra, side='left') {
  let Q = Ra, M = Ra * x;
  loads.forEach(l => {
    if (l.pos > x + EPS) return;
    if ((l.type === 'point' || l.type === 'moment') && Math.abs(l.pos - x) < EPS && side === 'left') return;
    let endPos = l.pos + l.length, effectiveLen = Math.max(0, Math.min(x, endPos) - l.pos);
    if (effectiveLen < EPS && l.type !== 'point' && l.type !== 'moment') return;
    let pLoad = { ...l, length: effectiveLen };
    if (l.type === 'trapezoid') pLoad.magEnd = l.mag + (l.magEnd - l.mag) * effectiveLen / l.length;
    
    if (l.type === 'moment') {
        M += l.mag; 
    } else {
        const r = getLoadIntegral(pLoad);
        Q -= r.totalForce; M -= (x * r.totalForce - r.momentA);
    }
  });
  return { Q, M };
}

function getLoadIntegral(l) {
  if (l.type === 'point') return { totalForce: l.mag, momentA: l.mag * l.pos };
  if (l.type === 'moment') return { totalForce: 0, momentA: l.mag }; 
  const w1=l.mag, w2=l.type==='trapezoid'?l.magEnd:l.mag, L=l.length;
  if (L <= 0) return { totalForce: 0, momentA: 0 };
  const F = L*(w1+w2)/2, distC = (w1+w2)===0 ? L/2 : (L/3) * (w1 + 2*w2) / (w1+w2); 
  return { totalForce: F, momentA: F * (l.pos + distC) };
}

function calcPhi(L, loads) {
  let phiL = 0, phiR = 0; 
  // ★[MODIFIED] Optimized Integration Step (1mm pitch = 1000 steps/m)
  const stepsPerMeter = 1000;
  // Cap max steps to prevent freezing on long spans
  const N = Math.min(Math.max(50, Math.ceil(L * stepsPerMeter)), 10000); 
  const dx = L/N;
  let sumP=0, sumM=0; loads.forEach(l=>{ const r=getLoadIntegral(l); sumP+=r.totalForce; sumM+=r.momentA; });
  const Rb = sumM/L, Ra = sumP - Rb;
  for(let i=0; i<N; i++) {
    const x = (i+0.5)*dx, M = getSectionForceSimple(x, loads, Ra).M;
    phiL += (M * (L-x)/L) * dx; phiR += (M * x/L) * dx;
  }
  return { phiL, phiR };
}

function solveLinearSystem(A, B) {
  const n = B.length;
  for (let i = 0; i < n; i++) {
    let maxEl = Math.abs(A[i][i]), maxRow = i;
    for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > maxEl) { maxEl = Math.abs(A[k][i]); maxRow = k; }
    for (let k = i; k < n; k++) [A[maxRow][k], A[i][k]] = [A[i][k], A[maxRow][k]];
    [B[maxRow], B[i]] = [B[i], B[maxRow]];
    for (let k = i + 1; k < n; k++) {
      const c = -A[k][i] / A[i][i];
      for (let j = i; j < n; j++) A[k][j] = (i === j ? 0 : A[k][j] + c * A[i][j]);
      B[k] += c * B[i];
    }
  }
  const x = new Array(n).fill(0);
  for (let i = n - 1; i > -1; i--) {
    let sum = 0; for (let k = i + 1; k < n; k++) sum += A[i][k] * x[k];
    x[i] = (B[i] - sum) / A[i][i];
  }
  return x;
}

function generateEmptyResult() {
  return { shearData:[], momentData:[], deflectionData:[], poiResults:[], spanBounds:[], reactions:[], bounds:{ maxShear:0, maxM_pos:0, maxM_neg:0, maxDeflection:0, maxSigma_pos:0, maxSigma_neg:0 } };
}

// --- Visual Components ---
function SectionProfileView({ props }) {
  const { shape, dims, axis, matType, isManualMode } = props;
  const size = 100, scale = 0.8;
  const cx = size / 2, cy = size / 2;
  let pathD = "";
  
  if (matType === 'manual') {
      // Dummy H shape for manual mode
      const H=s(200), B=s(100), t1=s(6), t2=s(8);
      pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)/2} v ${H-2*t2} h ${(B-t1)/2} v ${t2} h ${-B} v ${-t2} h ${(B-t1)/2} v ${-(H-2*t2)} h ${-(B-t1)/2} z`;
      return <svg width="100%" height="100%" viewBox="0 0 100 100"><path d={pathD} fill="#e2e8f0" stroke="#94a3b8" strokeWidth="1.5" strokeDasharray="3" /><text x={50} y={50} textAnchor="middle" fontSize="10" fill="#64748b" dominantBaseline="middle">Manual</text></svg>;
  }

  if (!dims.H) return null;
  const maxDim = Math.max(dims.H, dims.B);
  function s(v) { return (v / maxDim) * size * scale; }
  
  if (matType === 'concrete') {
    // RC断面
    const w = s(dims.B), h = s(dims.H); 
    pathD = `M ${cx-w/2} ${cy-h/2} h ${w} v ${h} h ${-w} z`;
    return (
      <svg width="100%" height="100%" viewBox="0 0 100 100">
        <path d={pathD} fill="#cbd5e1" stroke="#475569" strokeWidth="1.5" />
        <text x={cx} y={cy+h/2+10} textAnchor="middle" fontSize="8" fill="#475569">b={dims.B}</text>
        <text x={cx+w/2+2} y={cy} textAnchor="start" fontSize="8" fill="#475569">D={dims.H}</text>
      </svg>
    );
  } else {
    // 鋼材断面
    const H = s(dims.H), B = s(dims.B), t1 = s(dims.t1), t2 = s(dims.t2), C = s(dims.C_lip || 0);
    if (shape === 'H') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)/2} v ${H-2*t2} h ${(B-t1)/2} v ${t2} h ${-B} v ${-t2} h ${(B-t1)/2} v ${-(H-2*t2)} h ${-(B-t1)/2} z`;
    else if (shape === 'Channel') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${t2} h ${-(B-t1)} v ${H-2*t2} h ${B-t1} v ${t2} h ${-B} z`;
    else if (shape === 'Angle') pathD = `M ${cx-B/2} ${cy-H/2} v ${H} h ${B} v ${-t2} h ${-(B-t1)} v ${-(H-t2)} z`;
    else if (shape === 'LipChannel') pathD = `M ${cx-B/2} ${cy-H/2} h ${B} v ${C} h ${-t2} v ${-(C-t2)} h ${-(B-t1-t2)} v ${H-2*t2} h ${B-t1-t2} v ${-(C-t2)} h ${t2} v ${C} h ${-B} z`;
    else if (shape.includes('SheetPile')) {
        const dH = H, dB = B, dt = t1;
        pathD = `M ${cx-dB/2} ${cy-dH/2} v ${dH} h ${dB} v ${-dH} h ${-dt} v ${dH-dt} h ${-(dB-2*dt)} v ${-(dH-dt)} z`;
    } else if (shape === 'SquarePipe') {
        const dH = H, dB = B, dt = t1;
        // Outer rectangle (CCW) + Inner rectangle (CW) to create a hole
        pathD = `M ${cx-dB/2} ${cy-dH/2} h ${dB} v ${dH} h ${-dB} z M ${cx-(dB-2*dt)/2} ${cy-(dH-2*dt)/2} v ${dH-2*dt} h ${dB-2*dt} v ${-(dH-2*dt)} z`;
    }
  }
  return <svg width="100%" height="100%" viewBox="0 0 100 100"><path d={pathD} fill="#cbd5e1" stroke="#475569" strokeWidth="1.5" fillRule="evenodd" transform={axis === 'weak' ? `rotate(90, ${cx}, ${cy})` : ''} /></svg>;
}

function ResultBox({ label, val, x, unit, sub, color }) {
  return (
    <div className="bg-white p-3 rounded-lg border shadow-sm">
      <div className="text-[10px] text-slate-400 uppercase font-bold">{label}</div>
      <div className={`text-lg font-bold ${color}`}>{val?.toFixed(2)} <span className="text-xs text-slate-400">{unit}</span></div>
      <div className="flex gap-2 text-[10px]">
        {x !== undefined && <span className="bg-slate-100 px-1 rounded inline-block text-slate-500">x={x.toFixed(3)}m</span>}
        {sub && <span className="bg-slate-100 px-1 rounded inline-block text-slate-500">{sub}</span>}
      </div>
    </div>
  );
}

// ★[MODIFIED] PoiTable: Discontinuity Handling
function PoiTable({ finalPoiData, userPoi, setUserPoi, totalLength, spans, results, sectionProps }) {
  const addUserPoint = (globalX) => {
      const newId = Date.now();
      setUserPoi([...userPoi, { id: newId, x: globalX }]);
  };

  const updateUserPoint = (id, newGlobalX) => {
      setUserPoi(userPoi.map(p => p.id === id ? { ...p, x: newGlobalX } : p));
  };

  const removeUserPoint = (id) => {
      setUserPoi(userPoi.filter(p => p.id !== id));
  };

  const spanRanges = useMemo(() => {
    let currentX = 0; return spans.map(len => { const range = { start: currentX, end: currentX + len }; currentX += len; return range; });
  }, [spans]);

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-2"><h3 className="text-sm font-bold text-slate-600">着目点詳細 (スパン別)</h3></div>
      {spanRanges.map((range, sIdx) => {
        // Find points within this span range (inclusive of boundaries)
        const spanPoints = finalPoiData.filter(p => p.x >= range.start - 1e-4 && p.x <= range.end + 1e-4);
        
        return (
          <div key={sIdx} className="border rounded-lg overflow-hidden bg-white shadow-sm">
            <div className="bg-slate-100 px-3 py-1.5 text-xs font-bold text-slate-600 flex justify-between items-center">
                <span>径間 {sIdx + 1} ({String.fromCharCode(65+sIdx)} - {String.fromCharCode(65+sIdx+1)})</span>
                <div className="flex items-center gap-3">
                    <span className="font-normal opacity-70">スパン長: {spans[sIdx].toFixed(2)}m</span>
                    <button 
                        onClick={() => addUserPoint(range.start)} 
                        className="flex items-center gap-1 px-2 py-0.5 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors"
                    >
                        <Plus className="w-3 h-3"/> 追加
                    </button>
                </div>
            </div>
            <table className="w-full text-[11px] text-left">
              <thead className="bg-slate-50 text-slate-400 border-b"><tr><th className="p-2 w-24">Local x (m)</th><th className="p-2">Q (kN)</th><th className="p-2">M (kN·m)</th><th className="p-2">σ (N/mm²)</th><th className="p-2">δ (mm)</th><th className="w-8"></th></tr></thead>
              <tbody className="divide-y">
                {spanPoints.map((p, idx) => {
                  const localX = Math.max(0, Math.min(spans[sIdx], p.x - range.start));
                  const isUser = p.type === 'user';
                  
                  // ★[MODIFIED] Force span index to get isolated span results
                  const val = getResultAt(p.x, results, sectionProps, sIdx);

                  return (
                    // ★[MODIFIED] Use stable p.id as key instead of index to prevent input focus loss
                    <tr key={p.id} className={isUser ? "bg-blue-50/20" : "hover:bg-slate-50"}>
                      <td className="p-2">
                          <div className="flex items-center gap-1">
                              {isUser ? (
                                  <PoiInput 
                                    id={p.id}
                                    globalX={p.x}
                                    rangeStart={range.start}
                                    onUpdate={updateUserPoint}
                                  />
                              ) : (
                                  <div className="flex items-center gap-2">
                                      <span className="font-mono text-slate-500 w-12">{localX.toFixed(3)}</span>
                                      <span className="text-[9px] px-1 bg-slate-200 rounded text-slate-500">Auto</span>
                                  </div>
                              )}
                              {isUser && <span className="text-[9px] text-slate-300">m</span>}
                          </div>
                      </td>
                      <td className="p-2 font-mono text-slate-600">{val?.Q?.toFixed(2)}</td>
                      <td className="p-2 font-mono text-slate-600">{val?.M?.toFixed(2)}</td>
                      <td className="p-2 font-mono text-slate-700">{val?.sigma?.toFixed(1)}</td>
                      <td className="p-2 font-mono text-blue-600 font-bold">{val?.deflection?.toFixed(2)}</td>
                      <td className="p-2 text-right">
                          {isUser && (
                              <button onClick={() => removeUserPoint(p.id)}><X className="w-3 h-3 text-slate-300 hover:text-red-500" /></button>
                          )}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        );
      })}
    </div>
  );
}

function AdvancedVisualizer({ spans, supports, totalLength, loads, results, forceWidth }) {
  const containerRef = useRef(null);
  const [width, setWidth] = useState(forceWidth || 600);
  
  useEffect(() => {
    if (forceWidth) {
        setWidth(forceWidth);
        return;
    }
    if(containerRef.current) setWidth(containerRef.current.clientWidth);
    const h = () => { if(containerRef.current) setWidth(containerRef.current.clientWidth); };
    window.addEventListener('resize', h); return () => window.removeEventListener('resize', h);
  }, [forceWidth]);

  // ★[MODIFIED] Increased height and spacing between diagrams
  const height = 950, padding = { left: 50, right: 50, top: 40 };
  const scaleX = (v) => padding.left + (v / totalLength) * (width - padding.left - padding.right);
  
  // ★[MODIFIED] Vertical layout adjustments (Shifted +40px)
  const beamY = 120;
  const sfdY = 360; // 320 -> 360
  const bmdY = 610; // 570 -> 610
  const defY = 860; // 820 -> 860
  const graphH = 70;
  
  const { maxShear, maxM_pos, maxM_neg, maxDeflection } = results.bounds;
  const maxM = Math.max(Math.abs(maxM_pos), Math.abs(maxM_neg), 1), maxD = Math.max(Math.abs(maxDeflection), 0.1), maxQ = Math.max(Math.abs(maxShear), 1);
  const syQ = v => sfdY - (v/maxQ)*(graphH/2), syM = v => bmdY + (v/maxM)*(graphH/2), syD = v => defY + (v/maxD)*(graphH/2);
  const maxLoadMag = Math.max(...loads.map(l => Math.max(Math.abs(l.mag), Math.abs(l.magEnd || 0))), 1);
  const loadHScale = 40 / maxLoadMag;

  // [Step A] ラベル配置計算 (X座標固定・Y方向スタッキングのみ)
  const calculateLabelLayout = (rawPoints, baseY) => {
      // 1. ソート (左から右へ)
      // X座標自体はいじらず、純粋に並び順だけ整える
      let sorted = [...rawPoints].sort((a, b) => a.x - b.x);

      // ★削除: 以前あった「左右振り分け・Align変更ロジック」はここで完全廃止。

      const placedRects = []; 
      const results = [];
      
      // 定数設定 (v21.24の仕様を維持)
      const boxW = 120; // テキスト全体をカバーする幅
      const boxH = 16;  // 垂直方向のクリアランス

      sorted.forEach(p => {
          const originY = p.y;
          
          // 方向決定 (グラフの外側へ)
          const isVisuallyBelow = originY > baseY + 1; 
          const isVisuallyAbove = originY < baseY - 1; 
          let goUp;
          if (isVisuallyBelow) goUp = false;
          else if (isVisuallyAbove) goUp = true;
          else goUp = true;

          // 初期位置 (グラフ線に寄せる)
          const offsetUp = 10;
          const offsetDown = 12; 
          let candY = originY + (goUp ? -offsetUp : offsetDown);
          
          // 移動ステップ (矩形高さより大きくして隙間を作る)
          const shiftStep = goUp ? -17 : 17; 

          // 衝突判定
          for (let k = 0; k < 15; k++) { 
              let collision = false;
              for (const r of placedRects) {
                  const dx = Math.abs(p.x - r.x);
                  const dy = Math.abs(candY - r.y);
                  
                  // 厳密判定
                  if (dx < boxW && dy < boxH) {
                      collision = true;
                      break;
                  }
              }
              if (!collision) break; 
              candY += shiftStep;
          }

          // 確定位置を登録 (X座標はずらさない)
          placedRects.push({ x: p.x, y: candY }); 
          
          const showLine = Math.abs(candY - originY) > 25;
          
          // alignプロパティは返さない（JSX側で画面端判定のみさせる）
          results.push({ ...p, finalY: candY, originY, showLine });
      });

      return results;
  };

  // [Step B] データ収集ヘルパー
  const collectPoints = (dataArr, boundsArr, scaleYFunc, type) => {
      const points = [];
      if (!dataArr || dataArr.length === 0) return [];

      // 端点 (Start/End)
      // 始点近傍
      let startP = dataArr[0];
      for(let i=0; i<dataArr.length; i++) {
          if(dataArr[i].x > 0.0001) break;
          if(Math.abs(dataArr[i].y) > Math.abs(startP.y)) startP = dataArr[i];
      }
      points.push({ xVal: startP.x, val: startP.y });
      
      // 終点近傍
      let endP = dataArr[dataArr.length-1];
      const L = dataArr[dataArr.length-1].x;
      for(let i=dataArr.length-1; i>=0; i--) {
          if(dataArr[i].x < L - 0.0001) break;
          if(Math.abs(dataArr[i].y) > Math.abs(endP.y)) endP = dataArr[i];
      }
      points.push({ xVal: endP.x, val: endP.y });

      // スパンごとのピーク (spanBounds)
      boundsArr.forEach(sb => {
          if (type === 'M') {
              // BMD: 同じ位置なら絶対値が大きい方を採用（重複回避）
              if (Math.abs(sb.maxM_x - sb.minM_x) < 0.001) {
                  const val = Math.abs(sb.maxM) >= Math.abs(sb.minM) ? sb.maxM : sb.minM;
                  const x = Math.abs(sb.maxM) >= Math.abs(sb.minM) ? sb.maxM_x : sb.minM_x;
                  points.push({ xVal: x, val: val });
              } else {
                  points.push({ xVal: sb.maxM_x, val: sb.maxM });
                  points.push({ xVal: sb.minM_x, val: sb.minM });
              }
          } else if (type === 'Q') {
              points.push({ xVal: sb.maxQ_x, val: sb.maxQ });
              points.push({ xVal: sb.minQ_x, val: sb.minQ });
          } else { // Deflection
              points.push({ xVal: sb.maxD_x, val: sb.maxD });
              points.push({ xVal: sb.minD_x, val: sb.minD });
          }
      });

      // 重複除去と整形
      const uniquePoints = [];
      points.forEach(p => {
          // 既存リストに似たような点(X差<1mm, 値差<0.01)がなければ追加
          const exists = uniquePoints.some(ep => Math.abs(ep.xVal - p.xVal) < 0.001 && Math.abs(ep.val - p.val) < 0.01);
          if (!exists) {
              uniquePoints.push({
                  x: scaleX(p.xVal),
                  y: scaleYFunc(p.val),
                  val: p.val,
                  xVal: p.xVal,
                  unit: type === 'M' ? 'kN·m' : (type === 'Q' ? 'kN' : 'mm')
              });
          }
      });
      return uniquePoints;
  };

  // 各グラフのラベルデータ計算
  const sfdPoints = collectPoints(results.shearData, results.spanBounds, syQ, 'Q');
  const sfdLabels = calculateLabelLayout(sfdPoints, sfdY); 

  const bmdPoints = collectPoints(results.momentData, results.spanBounds, syM, 'M');
  const bmdLabels = calculateLabelLayout(bmdPoints, bmdY); 

  const defPoints = collectPoints(results.deflectionData, results.spanBounds, syD, 'D');
  const defLabels = calculateLabelLayout(defPoints, defY); 

  // 荷重テキストの重なり回避用（既存ロジック）
  const loadTextOccupied = useRef([]);
  loadTextOccupied.current = [];
  const getAdjustedLoadTextY = (x, yBase, isBottom) => {
      let y = yBase, shift = isBottom ? 13 : -13;
      for(let i=0; i<5; i++) {
         let collision = false;
         for (let l of loadTextOccupied.current) if (Math.abs(x - l.x) < 40 && Math.abs(y - l.y) < 12) { collision = true; break; }
         if (!collision) break;
         y += shift; 
      }
      loadTextOccupied.current.push({ x, y }); return y;
  };

  return (
    <div ref={containerRef} className="w-full select-none">
      <svg width={width} height={height} className="overflow-visible">
        <defs>
          <marker id="arrow" markerWidth="8" markerHeight="5" refX="7.5" refY="2.5" orient="auto">
            <polygon points="0 0, 8 2.5, 0 5" fill={COLORS.load} />
          </marker>
        </defs>
        
        <g key={`${totalLength}-${spans.join('-')}`}>
          {(() => {
            const guidePoints = new Set([0, totalLength]);
            let cx = 0; spans.forEach(s => { cx += s; guidePoints.add(cx); });
            loads.forEach(l => { guidePoints.add(l.pos); if(l.type !== 'point') guidePoints.add(l.pos + l.length); });
            return Array.from(guidePoints).map((gx, i) => <line key={i} x1={scaleX(gx)} y1={beamY+20} x2={scaleX(gx)} y2={height-20} stroke={COLORS.guide} strokeWidth="0.5" strokeDasharray="3" opacity="0.3" />);
          })()}

          {/* 寸法表示 */}
          {spans.map((len, i) => {
             let sx_val = 0; for(let k=0; k<i; k++) sx_val += spans[k];
             const x1 = scaleX(sx_val), x2 = scaleX(sx_val + len);
             return (
               <g key={`dim-span-${i}`}>
                 <text x={(x1+x2)/2} y={beamY + 45} textAnchor="middle" fontSize="10" fill={COLORS.dim}>{len}m</text>
                 <line x1={x1} y1={beamY + 35} x2={x2} y2={beamY + 35} stroke={COLORS.dim} strokeWidth="0.8" />
                 <line x1={x1} y1={beamY + 32} x2={x1} y2={beamY + 38} stroke={COLORS.dim} strokeWidth="0.8" />
                 <line x1={x2} y1={beamY + 32} x2={x2} y2={beamY + 38} stroke={COLORS.dim} strokeWidth="0.8" />
               </g>
             );
          })}

          <line x1={scaleX(0)} y1={beamY} x2={scaleX(totalLength)} y2={beamY} stroke={COLORS.beam} strokeWidth="4" />
          
          {/* 支点アイコン */}
          {supports.map((type, i) => {
            let cx = 0; for(let k=0;k<i;k++) cx += (k<spans.length?spans[k]:0);
            const x = scaleX(cx); if (type === 'free') return null;
            let icon = (type === 'fixed') ? <line x1={x} y1={beamY-15} x2={x} y2={beamY+15} stroke={COLORS.support} strokeWidth="6"/> : (type === 'pin') ? <polygon points={`${x},${beamY} ${x-6},${beamY+10} ${x+6},${beamY+10}`} fill="none" stroke={COLORS.support} strokeWidth="2"/> : <g><polygon points={`${x},${beamY} ${x-6},${beamY+10} ${x+6},${beamY+10}`} fill="none" stroke={COLORS.support} strokeWidth="2"/><line x1={x-8} y1={beamY+13} x2={x+8} y2={beamY+13} stroke={COLORS.support} strokeWidth="1"/></g>;
            return <g key={`supp-label-${i}`}>{icon}<text x={x} y={beamY + 25} textAnchor="middle" fontSize="11" fontWeight="bold" fill={COLORS.support}>{String.fromCharCode(65 + i)}</text></g>;
          })}

          {/* 荷重描画 */}
          {(() => {
            const posStack = {}, negStack = {};
            return [...loads].sort((a, b) => a.pos - b.pos).map(l => {
                const isNeg = l.mag < 0, stack = isNeg ? negStack : posStack, key = Math.round(l.pos * 10), count = stack[key] || 0; stack[key] = count + 1;
                const shift = count * 30, x = scaleX(l.pos);
                const pointOffset = (l.type === 'point') ? 20 : 0;
                const h1 = Math.abs(l.mag) * loadHScale + pointOffset; 
                const currentBeamY = isNeg ? (beamY + shift) : (beamY - shift);
                const baseY = isNeg ? (currentBeamY + h1 + 15) : (currentBeamY - h1 - 5), textY = getAdjustedLoadTextY(x, baseY, isNeg), posTextY = isNeg ? (textY + 12) : (textY - 12);
              
                if(l.type==='point') {
                   const yS = isNeg ? currentBeamY + h1 : currentBeamY - h1, yE = isNeg ? currentBeamY + 5 : currentBeamY - 5;
                   return <g key={l.id}>{shift > 0 && <line x1={x} y1={currentBeamY} x2={x} y2={beamY} stroke={COLORS.load} strokeWidth="1" strokeDasharray="2" opacity="0.5" />}<line x1={x} y1={yS} x2={x} y2={yE} stroke={COLORS.load} strokeWidth="2" markerEnd="url(#arrow)"/><text x={x} y={textY} textAnchor="middle" fontSize="10" fill={COLORS.load} fontWeight="bold">{l.mag}kN</text><text x={x} y={posTextY} textAnchor="middle" fontSize="9" fill={COLORS.dim}>x={l.pos}m</text></g>;
                } else if (l.type === 'moment') {
                   // ★[MODIFIED] 3/4 Circular Arrow
                   const yCenter = currentBeamY - 20;
                   const r = 16; 
                   const isCW = l.mag > 0;
                   
                   return <g key={l.id}>
                        {shift > 0 && <line x1={x} y1={currentBeamY} x2={x} y2={beamY} stroke={COLORS.load} strokeWidth="1" strokeDasharray="2" opacity="0.5" />}
                        
                        <circle cx={x} cy={yCenter} r="2" fill={COLORS.load} />

                        {/* Arc */}
                        <path 
                            d={isCW 
                                ? `M ${x} ${yCenter-r} A ${r} ${r} 0 1 1 ${x-r} ${yCenter}` // Start 12, End 9 (CW)
                                : `M ${x} ${yCenter-r} A ${r} ${r} 0 1 0 ${x+r} ${yCenter}` // Start 12, End 3 (CCW)
                            } 
                            fill="none" 
                            stroke={COLORS.load} 
                            strokeWidth="2.5" 
                        />

                        {/* Arrow Tip (Triangle) - Adjusted orientation tangential to the circle at the end point */}
                        <path 
                            d={isCW 
                                ? `M ${x-r} ${yCenter-6} L ${x-r-5} ${yCenter+4} L ${x-r+5} ${yCenter+4} Z` // At 9 o'clock, pointing UP
                                : `M ${x+r} ${yCenter-6} L ${x+r-5} ${yCenter+4} L ${x+r+5} ${yCenter+4} Z` // At 3 o'clock, pointing UP
                            } 
                            fill={COLORS.load} 
                        />

                        <text x={x} y={yCenter - r - 8} textAnchor="middle" fontSize="10" fill={COLORS.load} fontWeight="bold">{l.mag}kN·m</text>
                        <text x={x} y={posTextY} textAnchor="middle" fontSize="9" fill={COLORS.dim}>x={l.pos}m</text>
                   </g>;
                } else {
                   const x2 = scaleX(l.pos + l.length), mag2 = l.type === 'trapezoid' ? l.magEnd : l.mag, h2 = Math.abs(mag2) * loadHScale, y1P = isNeg ? currentBeamY + h1 : currentBeamY - h1, y2P = mag2 < 0 ? currentBeamY + h2 : currentBeamY - h2;
                   
                   if ((l.mag > 0 && mag2 < 0) || (l.mag < 0 && mag2 > 0)) {
                      const ratio = Math.abs(l.mag) / (Math.abs(l.mag) + Math.abs(mag2));
                      const xMid = x + (x2 - x) * ratio;
                      return (
                        <g key={l.id}>
                          {shift > 0 && <g><line x1={x} y1={currentBeamY} x2={x} y2={beamY} stroke={COLORS.load} strokeWidth="1" strokeDasharray="2" opacity="0.5" /><line x1={x2} y1={currentBeamY} x2={x2} y2={beamY} stroke={COLORS.load} strokeWidth="1" strokeDasharray="2" opacity="0.5" /></g>}
                          <polygon points={`${x},${currentBeamY} ${x},${y1P} ${xMid},${currentBeamY}`} fill={COLORS.loadPolygon} />
                          <polygon points={`${xMid},${currentBeamY} ${x2},${y2P} ${x2},${currentBeamY}`} fill={COLORS.loadPolygon} />
                          <line x1={x} y1={y1P} x2={xMid} y2={currentBeamY} stroke={COLORS.load} strokeWidth="1.5"/>
                          <line x1={xMid} y1={currentBeamY} x2={x2} y2={y2P} stroke={COLORS.load} strokeWidth="1.5"/>
                          <text x={x} y={textY} textAnchor="end" fontSize="10" fill={COLORS.load} fontWeight="bold">{l.mag}kN/m</text>
                          <text x={x2} y={getAdjustedLoadTextY(x2, (mag2 < 0 ? currentBeamY + h2 + 15 : currentBeamY - h2 - 5), mag2 < 0)} textAnchor="start" fontSize="10" fill={COLORS.load} fontWeight="bold">{mag2}kN/m</text>
                        </g>
                      );
                   }
                   
                   return <g key={l.id}>{shift > 0 && <g><line x1={x} y1={currentBeamY} x2={x} y2={beamY} stroke={COLORS.load} strokeWidth="1" strokeDasharray="2" opacity="0.5" /><line x1={x2} y1={currentBeamY} x2={x2} y2={beamY} stroke={COLORS.load} strokeWidth="1" strokeDasharray="2" opacity="0.5" /></g>}<polygon points={`${x},${currentBeamY} ${x},${y1P} ${x2},${y2P} ${x2},${currentBeamY}`} fill={COLORS.loadPolygon} /><line x1={x} y1={y1P} x2={x2} y2={y2P} stroke={COLORS.load} strokeWidth="1.5"/><text x={x} y={textY} textAnchor="end" fontSize="10" fill={COLORS.load} fontWeight="bold">{l.mag}kN/m</text><text x={x2} y={getAdjustedLoadTextY(x2, (mag2 < 0 ? currentBeamY + h2 + 15 : currentBeamY - h2 - 5), mag2 < 0)} textAnchor="start" fontSize="10" fill={COLORS.load} fontWeight="bold">{mag2}kN/m</text><text x={(x+x2)/2} y={posTextY} textAnchor="middle" fontSize="9" fill={COLORS.dim}>x={l.pos}~{(l.pos+l.length).toFixed(1)}m</text></g>;
                }
            });
          })()}

          {/* 解析結果グラフ (SFD) */}
          <g>
            <text x={10} y={sfdY - 75} fontSize="10" fontWeight="bold" fill={COLORS.shearLine}>せん断力図 (SFD) [kN]</text>
            <line x1={scaleX(0)} y1={sfdY} x2={scaleX(totalLength)} y2={sfdY} stroke="#cbd5e1" strokeDasharray="2"/>
            <path d={`M ${scaleX(0)} ${sfdY} ` + results.shearData.map(p=>`L ${scaleX(p.x)} ${syQ(p.y)}`).join(' ') + ` L ${scaleX(totalLength)} ${sfdY}`} fill={COLORS.shearFill} opacity="0.6"/><path d={`M ${scaleX(0)} ${syQ(results.shearData[0]?.y||0)} ` + results.shearData.map(p=>`L ${scaleX(p.x)} ${syQ(p.y)}`).join(' ')} fill="none" stroke={COLORS.shearLine} strokeWidth="1.5"/>
            
            {/* ★[MODIFIED] Use Pre-calculated Labels */}
            {sfdLabels.map((lbl, i) => {
                const anchor = (lbl.x < padding.left + 40) ? "start" : (lbl.x > width - padding.right - 40) ? "end" : "middle";
                const showLine = lbl.showLine;
                return (
                    <g key={i}>
                        {showLine && <line x1={lbl.x} y1={lbl.originY} x2={lbl.x} y2={lbl.finalY + (lbl.val>=0?5:-5)} stroke={COLORS.shearLine} strokeWidth="0.5" opacity="0.5" />}
                        <text x={lbl.x} y={lbl.finalY} textAnchor={anchor} fontSize="10" fill={COLORS.shearLine} fontWeight="bold">
                            {lbl.val > 0 ? '+' : ''}{lbl.val.toFixed(2)}{lbl.unit} <tspan fontSize="9" fill={COLORS.dim} dx="4">(x={lbl.xVal.toFixed(3)}m)</tspan>
                        </text>
                        <circle cx={lbl.x} cy={lbl.originY} r="2" fill={COLORS.shearLine} />
                    </g>
                );
            })}
          </g>

          {/* 解析結果グラフ (BMD) */}
          <g>
            <text x={10} y={bmdY - 75} fontSize="10" fontWeight="bold" fill={COLORS.momentLine}>曲げモーメント図 (BMD) [kN·m]</text>
            <line x1={scaleX(0)} y1={bmdY} x2={scaleX(totalLength)} y2={bmdY} stroke="#cbd5e1" strokeDasharray="2"/>
            <path d={`M ${scaleX(0)} ${bmdY} ` + results.momentData.map(p=>`L ${scaleX(p.x)} ${syM(p.y)}`).join(' ') + ` L ${scaleX(totalLength)} ${bmdY}`} fill={COLORS.momentFill} opacity="0.6"/><path d={`M ${scaleX(0)} ${syM(results.momentData[0]?.y||0)} ` + results.momentData.map(p=>`L ${scaleX(p.x)} ${syM(p.y)}`).join(' ')} fill="none" stroke={COLORS.momentLine} strokeWidth="1.5"/>
            
            {/* ★[MODIFIED] Use Pre-calculated Labels */}
            {bmdLabels.map((lbl, i) => {
                const anchor = (lbl.x < padding.left + 40) ? "start" : (lbl.x > width - padding.right - 40) ? "end" : "middle";
                const showLine = lbl.showLine;
                return (
                    <g key={i}>
                        {showLine && <line x1={lbl.x} y1={lbl.originY} x2={lbl.x} y2={lbl.finalY + (lbl.val>=0?5:-5)} stroke={COLORS.momentLine} strokeWidth="0.5" opacity="0.5" />}
                        <text x={lbl.x} y={lbl.finalY} textAnchor={anchor} fontSize="10" fill={COLORS.momentLine} fontWeight="bold">
                            {lbl.val > 0 ? '+' : ''}{lbl.val.toFixed(2)}{lbl.unit} <tspan fontSize="9" fill={COLORS.dim} dx="4">(x={lbl.xVal.toFixed(3)}m)</tspan>
                        </text>
                        <circle cx={lbl.x} cy={lbl.originY} r="2" fill={COLORS.momentLine} />
                    </g>
                );
            })}
          </g>

          {/* 解析結果グラフ (Deflection) */}
          <g>
            <text x={10} y={defY - 75} fontSize="10" fontWeight="bold" fill={COLORS.deflLine}>変位図 (たわみ) [mm]</text>
            <line x1={scaleX(0)} y1={defY} x2={scaleX(totalLength)} y2={defY} stroke="#cbd5e1" strokeDasharray="2"/>
            <path d={`M ${scaleX(0)} ${defY} ` + results.deflectionData.map(p=>`L ${scaleX(p.x)} ${syD(p.y)}`).join(' ') + ` L ${scaleX(totalLength)} ${defY}`} fill={COLORS.deflFill} opacity="0.4"/><path d={`M ${scaleX(0)} ${syD(results.deflectionData[0]?.y||0)} ` + results.deflectionData.map(p=>`L ${scaleX(p.x)} ${syD(p.y)}`).join(' ')} fill="none" stroke={COLORS.deflLine} strokeWidth="1.5"/>
            
            {/* ★[MODIFIED] Use Pre-calculated Labels */}
            {defLabels.map((lbl, i) => {
                const anchor = (lbl.x < padding.left + 40) ? "start" : (lbl.x > width - padding.right - 40) ? "end" : "middle";
                const showLine = lbl.showLine;
                return (
                    <g key={i}>
                        {showLine && <line x1={lbl.x} y1={lbl.originY} x2={lbl.x} y2={lbl.finalY + (lbl.val>=0?5:-5)} stroke={COLORS.deflLine} strokeWidth="0.5" opacity="0.5" />}
                        <text x={lbl.x} y={lbl.finalY} textAnchor={anchor} fontSize="10" fill={COLORS.deflLine} fontWeight="bold">
                            {lbl.val > 0 ? '+' : ''}{lbl.val.toFixed(2)}{lbl.unit} <tspan fontSize="9" fill={COLORS.dim} dx="4">(x={lbl.xVal.toFixed(3)}m)</tspan>
                        </text>
                        <circle cx={lbl.x} cy={lbl.originY} r="2" fill={COLORS.deflLine} />
                    </g>
                );
            })}
          </g>
        </g>
      </svg>
    </div>
  );
}

// Reactアプリのマウント
const root = createRoot(document.getElementById('root'));
root.render(<App />);

</script>
</body>
</html>
